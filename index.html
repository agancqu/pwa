<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <title>Robot Twin BLE 3.2 (Sync Fix)</title>
    <style>
        :root { --primary: #007AFF; --bg: #f4f7f9; --card-bg: #ffffff; }
        body { text-align: center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--bg); padding: 10px; margin: 0; color: #333; }
        
        .card { 
            background: var(--card-bg); border-radius: 20px; padding: 20px; margin: 10px auto; 
            max-width: 420px; box-shadow: 0 8px 20px rgba(0,0,0,0.08); 
        }

        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        h2 { margin: 0; font-size: 1.2rem; }
        .badge { font-size: 0.8rem; padding: 4px 8px; border-radius: 12px; background: #eee; color: #666; }
        .badge.connected { background: #34C759; color: white; }

        .canvas-container { position: relative; width: 100%; padding-top: 100%; background: #f9f9f9; border-radius: 15px; border: 1px solid #eee; margin-bottom: 15px; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        .btn { 
            background: var(--primary); color: white; border: none; padding: 14px; 
            border-radius: 12px; width: 100%; font-size: 1rem; font-weight: 600;
            cursor: pointer; margin-top: 10px; transition: opacity 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .btn:active { opacity: 0.8; }
        .btn:disabled { background: #e0e0e0; color: #999; cursor: not-allowed; }
        .btn-stop { background: #FF3B30; }
        .btn-outline { background: transparent; border: 2px solid var(--primary); color: var(--primary); }
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }

        #status { margin-top: 15px; font-size: 0.9rem; color: #666; min-height: 20px; word-break: break-all;}
        
        .progress-bar { height: 6px; background: #eee; border-radius: 3px; margin: 15px 0; overflow: hidden; display: none; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.3s; }
        
        .debug-panel { margin-top: 20px; padding-top: 15px; border-top: 1px dashed #eee; display: none; }
    </style>
</head>
<body>

    <div class="card">
        <div class="header">
            <h2>ğŸ¨ ESP32 Robot Twin</h2>
            <span id="connectionBadge" class="badge">æœªè¿æ¥</span>
        </div>

        <div class="canvas-container">
            <canvas id="preview"></canvas>
        </div>

        <div id="progressContainer" class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
        </div>

        <div id="status">å‡†å¤‡å°±ç»ªï¼Œè¯·è¿æ¥è®¾å¤‡</div>

        <button id="connectBtn" class="btn" onclick="toggleConnection()">ğŸ“¡ è¿æ¥è“ç‰™è®¾å¤‡</button>
        
        <input type="file" id="fileInput" accept=".gcode,.txt,.nc" style="display:none" onchange="handleFileSelect(this.files[0])">
        <button id="loadBtn" class="btn btn-outline" onclick="document.getElementById('fileInput').click()" disabled>ğŸ“‚ 1. åŠ è½½ G-Code</button>
        <button id="uploadBtn" class="btn" onclick="startUploadAndPrint()" disabled>â–¶ï¸ 2. ä¸Šä¼ å¹¶å¼€å§‹æ‰“å°</button>

        <div class="btn-group">
            <button id="stopBtn" class="btn btn-stop" onclick="sendCommand('CMD:STOP')" disabled>â¸ æš‚åœ</button>
            <button class="btn btn-outline" onclick="toggleDebug()">ğŸ›  è°ƒè¯•</button>
        </div>

        <div id="debugPanel" class="debug-panel">
            <div class="btn-group">
                <button class="btn btn-outline" onclick="sendCommand('CMD:SERVO_FWD')">â¬‡ è½ç¬”</button>
                <button class="btn btn-outline" onclick="sendCommand('CMD:SERVO_REV')">â¬† æŠ¬ç¬”</button>
            </div>
            <div style="margin-top:10px; font-size:0.8rem; color:#999;">UUID: ...34fb</div>
        </div>
    </div>

    <script>
        const SERVICE_UUID   = '000000ff-0000-1000-8000-00805f9b34fb';
        const CHAR_CMD_UUID  = '0000ff01-0000-1000-8000-00805f9b34fb';
        const CHAR_STAT_UUID = '0000ff02-0000-1000-8000-00805f9b34fb';
        
        let device, server, service, charCmd, charStat;
        let gcodeContent = "";
        let autoScale = 1.0;
        let canvas, ctx, width, height;
        let isConnected = false;
        
        // --- æ ¸å¿ƒä¼˜åŒ–å˜é‡ ---
        let allParsedLines = []; // å­˜å‚¨æ‰€æœ‰é¢„è§£æçš„åæ ‡ç‚¹
        let lastDrawnIndex = 0;  // ä¸Šä¸€æ¬¡ç”»åˆ°çš„è¡Œå·
        
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js').catch(console.error);
        }

        window.onload = () => {
            canvas = document.getElementById('preview');
            ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            width = rect.width;
            height = rect.height;
            resetCanvas();
        };

        async function toggleConnection() {
            if (isConnected) disconnectBLE();
            else connectBLE();
        }

        async function connectBLE() {
            updateStatus("æ­£åœ¨æœç´¢è®¾å¤‡...", "blue");
            try {
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_UUID] }],
                    optionalServices: [SERVICE_UUID]
                });

                device.addEventListener('gattserverdisconnected', onDisconnected);
                updateStatus("æ­£åœ¨è¿æ¥ GATT...", "blue");
                
                server = await device.gatt.connect();
                service = await server.getPrimaryService(SERVICE_UUID);
                
                charCmd = await service.getCharacteristic(CHAR_CMD_UUID);
                charStat = await service.getCharacteristic(CHAR_STAT_UUID);

                await charStat.startNotifications();
                charStat.addEventListener('characteristicvaluechanged', handleStatusUpdate);

                onConnected();
            } catch (error) {
                console.error(error);
                let msg = error.message || error.toString();
                if (msg.includes("User cancelled")) msg = "ç”¨æˆ·å–æ¶ˆæ“ä½œ";
                updateStatus("æœªè¿æ¥ï¼š" + msg, "red");
            }
        }

        function disconnectBLE() {
            if (device && device.gatt.connected) device.gatt.disconnect();
        }

        function onConnected() {
            isConnected = true;
            document.getElementById('connectionBadge').innerText = "å·²è¿æ¥";
            document.getElementById('connectionBadge').classList.add("connected");
            document.getElementById('connectBtn').innerText = "âŒ æ–­å¼€è¿æ¥";
            document.getElementById('connectBtn').classList.add("btn-outline");
            document.getElementById('loadBtn').disabled = false;
            if (gcodeContent) document.getElementById('uploadBtn').disabled = false;
            updateStatus("è®¾å¤‡å·²å°±ç»ª", "green");
        }

        function onDisconnected() {
            isConnected = false;
            document.getElementById('connectionBadge').innerText = "æœªè¿æ¥";
            document.getElementById('connectionBadge').classList.remove("connected");
            document.getElementById('connectBtn').innerText = "ğŸ“¡ è¿æ¥è“ç‰™è®¾å¤‡";
            document.getElementById('connectBtn').classList.remove("btn-outline");
            document.getElementById('loadBtn').disabled = true;
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            updateStatus("è®¾å¤‡å·²æ–­å¼€", "orange");
        }

        async function handleFileSelect(file) {
            if (!file) return;
            const text = await file.text();
            gcodeContent = text;
            
            // é¢„å¤„ç†æ‰€æœ‰çº¿æ¡
            calculateScale(text);
            parseAllLines(text); // è§£æå­˜å…¥å†…å­˜
            
            resetCanvas();
            drawPreview(text, '#e0e0e0');
            lastDrawnIndex = 0; // é‡ç½®ç»˜åˆ¶è¿›åº¦
            
            document.getElementById('uploadBtn').disabled = !isConnected;
            updateStatus(`å·²åŠ è½½: ${file.name} (${(file.size/1024).toFixed(1)}KB)`, "black");
        }

        async function startUploadAndPrint() {
            if (!gcodeContent || !charCmd) return;

            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('progressContainer').style.display = 'block';
            lastDrawnIndex = 0; // æ‰“å°å¼€å§‹ï¼Œé‡ç½®è¿›åº¦
            
            try {
                updateStatus("æ­£åœ¨åˆå§‹åŒ–...", "blue");
                await sendCommand("CMD:NEWFILE");

                const lines = gcodeContent.split('\n');
                const total = lines.length;
                
                for (let i = 0; i < total; i++) {
                    const line = lines[i].trim();
                    if (line.length === 0 || line.startsWith(';')) continue;
                    
                    await sendCommand(line + "\n");
                    
                    if (i % 20 === 0) {
                        const pct = Math.round((i / total) * 100);
                        document.getElementById('progressFill').style.width = pct + "%";
                        updateStatus(`ä¸Šä¼ ä¸­... ${pct}%`, "blue");
                        await new Promise(r => setTimeout(r, 10));
                    }
                }
                
                updateStatus("å‘é€å¯åŠ¨æŒ‡ä»¤...", "blue");
                await sendCommand("CMD:START");
                
            } catch (e) {
                updateStatus("ä¸Šä¼ ä¸­æ–­: " + e.message, "red");
                document.getElementById('uploadBtn').disabled = false;
            }
        }

        async function sendCommand(cmd) {
            if (!charCmd) return;
            const encoder = new TextEncoder();
            await charCmd.writeValue(encoder.encode(cmd));
        }

        // --- æ ¸å¿ƒä¿®å¤ï¼šåŸºäº Index çš„åŒæ­¥ç»˜å›¾ ---
        function handleStatusUpdate(event) {
            const value = event.target.value;
            const decoder = new TextDecoder();
            const jsonStr = decoder.decode(value);
            
            try {
                const data = JSON.parse(jsonStr);
                // åè®®: {"s":status, "i":current_line_index}
                
                if (data.s === 1) { // Running
                    // è®¡ç®—æ€»è¿›åº¦ç™¾åˆ†æ¯” (é¿å…ä¾èµ–ESP32çš„på€¼)
                    const total = allParsedLines.length;
                    const pct = total > 0 ? Math.round((data.i / total) * 100) : 0;
                    updateStatus(`æ­£åœ¨ç»˜åˆ¶: ${pct}% (è¡Œ ${data.i})`, "green");
                    document.getElementById('progressFill').style.width = pct + "%";
                } else if (data.s === 3) { // Finished
                    updateStatus("ç»˜åˆ¶å®Œæˆ! ğŸ‰", "green");
                    document.getElementById('uploadBtn').disabled = false;
                }

                // è¡¥ç”»é€»è¾‘ï¼šä»ä¸Šæ¬¡ç”»åˆ°çš„åœ°æ–¹ï¼Œç”»åˆ°å½“å‰æŠ¥å‘Šçš„åœ°æ–¹
                if (data.i > lastDrawnIndex) {
                    drawSegment(lastDrawnIndex, data.i);
                    lastDrawnIndex = data.i;
                }

            } catch (e) {
                console.warn("JSON Error");
            }
        }

        // --- ç»˜å›¾é€»è¾‘ ---
        
        // é¢„è§£ææ‰€æœ‰åæ ‡ç‚¹ï¼Œé¿å…æ¯æ¬¡é‡ç®—
        function parseAllLines(text) {
            allParsedLines = [];
            let curX = 0, curY = 0;
            let isDown = false;
            
            text.split('\n').forEach((line, index) => {
                if (line.includes('M3')) isDown = true;
                if (line.includes('M5')) isDown = false;
                
                const xMatch = line.match(/X([\d.]+)/);
                const yMatch = line.match(/Y([\d.]+)/);
                
                if (xMatch) curX = parseFloat(xMatch[1]) * autoScale;
                if (yMatch) curY = parseFloat(yMatch[1]) * autoScale;
                
                // å­˜å…¥ç»“æ„åŒ–æ•°æ®
                allParsedLines.push({
                    x: curX,
                    y: curY,
                    isDown: isDown,
                    valid: (line.includes('G0') || line.includes('G1'))
                });
            });
        }

        // è¡¥ç”»å‡½æ•°ï¼šç”»å‡º startIdx åˆ° endIdx ä¹‹é—´çš„æ‰€æœ‰çº¿æ®µ
        function drawSegment(startIdx, endIdx) {
            if (endIdx >= allParsedLines.length) endIdx = allParsedLines.length - 1;
            
            ctx.beginPath();
            ctx.strokeStyle = '#007AFF'; // å­ªç”Ÿé«˜äº®è‰²
            ctx.lineWidth = 2;
            
            // æ‰¾åˆ°èµ·ç‚¹
            let startPoint = allParsedLines[startIdx];
            if(!startPoint) return;
            
            let drawStartX = startPoint.x + 10;
            let drawStartY = height - (startPoint.y + 10);
            ctx.moveTo(drawStartX, drawStartY);

            for (let i = startIdx + 1; i <= endIdx; i++) {
                const p = allParsedLines[i];
                if (p.valid) {
                    const drawX = p.x + 10;
                    const drawY = height - (p.y + 10);
                    
                    // åªæœ‰è½ç¬”æ—¶æ‰ç”»çº¿ï¼Œå¦åˆ™åªæ˜¯ç§»åŠ¨
                    if (p.isDown) {
                        ctx.lineTo(drawX, drawY);
                    } else {
                        ctx.moveTo(drawX, drawY);
                    }
                }
            }
            ctx.stroke();
        }

        function resetCanvas() {
            ctx.clearRect(0, 0, width, height);
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
        }

        function calculateScale(text) {
            let maxX = 0, maxY = 0;
            text.split('\n').forEach(line => {
                const x = line.match(/X([\d.]+)/);
                const y = line.match(/Y([\d.]+)/);
                if (x) maxX = Math.max(maxX, parseFloat(x[1]));
                if (y) maxY = Math.max(maxY, parseFloat(y[1]));
            });
            const padding = 20;
            const availW = width - padding * 2;
            const availH = height - padding * 2;
            if (maxX > 0 && maxY > 0) {
                autoScale = Math.min(availW / maxX, availH / maxY);
            } else {
                autoScale = 1.0;
            }
        }

        function drawPreview(text, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            let curX = 0, curY = 0;
            let isDown = false;

            text.split('\n').forEach(line => {
                if (line.includes('M3')) isDown = true;
                if (line.includes('M5')) isDown = false;
                const xMatch = line.match(/X([\d.]+)/);
                const yMatch = line.match(/Y([\d.]+)/);
                if (xMatch) curX = parseFloat(xMatch[1]) * autoScale;
                if (yMatch) curY = parseFloat(yMatch[1]) * autoScale;
                const drawX = curX + 10;
                const drawY = height - (curY + 10);

                if (line.includes('G0') || line.includes('G1')) {
                    if (isDown) ctx.lineTo(drawX, drawY);
                    else ctx.moveTo(drawX, drawY);
                }
            });
            ctx.stroke();
        }

        function updateStatus(msg, color="black") {
            const el = document.getElementById('status');
            el.innerText = msg;
            el.style.color = color;
        }

        function toggleDebug() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        }
    </script>
</body>
</html>