<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <title>Robot Twin BLE 3.1 (Fixed)</title>
    <style>
        :root { --primary: #007AFF; --bg: #f4f7f9; --card-bg: #ffffff; }
        body { text-align: center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--bg); padding: 10px; margin: 0; color: #333; }
        
        .card { 
            background: var(--card-bg); border-radius: 20px; padding: 20px; margin: 10px auto; 
            max-width: 420px; box-shadow: 0 8px 20px rgba(0,0,0,0.08); 
        }

        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        h2 { margin: 0; font-size: 1.2rem; }
        .badge { font-size: 0.8rem; padding: 4px 8px; border-radius: 12px; background: #eee; color: #666; }
        .badge.connected { background: #34C759; color: white; }

        .canvas-container { position: relative; width: 100%; padding-top: 100%; background: #f9f9f9; border-radius: 15px; border: 1px solid #eee; margin-bottom: 15px; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        .btn { 
            background: var(--primary); color: white; border: none; padding: 14px; 
            border-radius: 12px; width: 100%; font-size: 1rem; font-weight: 600;
            cursor: pointer; margin-top: 10px; transition: opacity 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .btn:active { opacity: 0.8; }
        .btn:disabled { background: #e0e0e0; color: #999; cursor: not-allowed; }
        .btn-stop { background: #FF3B30; }
        .btn-outline { background: transparent; border: 2px solid var(--primary); color: var(--primary); }
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }

        #status { margin-top: 15px; font-size: 0.9rem; color: #666; min-height: 20px; word-break: break-all;}
        
        .progress-bar { height: 6px; background: #eee; border-radius: 3px; margin: 15px 0; overflow: hidden; display: none; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.3s; }
        
        .debug-panel { margin-top: 20px; padding-top: 15px; border-top: 1px dashed #eee; display: none; }
    </style>
</head>
<body>

    <div class="card">
        <div class="header">
            <h2>ğŸ¨ ESP32 Robot Twin</h2>
            <span id="connectionBadge" class="badge">æœªè¿æ¥</span>
        </div>

        <div class="canvas-container">
            <canvas id="preview"></canvas>
        </div>

        <div id="progressContainer" class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
        </div>

        <div id="status">å‡†å¤‡å°±ç»ªï¼Œè¯·è¿æ¥è®¾å¤‡</div>

        <button id="connectBtn" class="btn" onclick="toggleConnection()">ğŸ“¡ è¿æ¥è“ç‰™è®¾å¤‡</button>
        
        <input type="file" id="fileInput" accept=".gcode,.txt,.nc" style="display:none" onchange="handleFileSelect(this.files[0])">
        <button id="loadBtn" class="btn btn-outline" onclick="document.getElementById('fileInput').click()" disabled>ğŸ“‚ 1. åŠ è½½ G-Code</button>
        <button id="uploadBtn" class="btn" onclick="startUploadAndPrint()" disabled>â–¶ï¸ 2. ä¸Šä¼ å¹¶å¼€å§‹æ‰“å°</button>

        <div class="btn-group">
            <button id="stopBtn" class="btn btn-stop" onclick="sendCommand('CMD:STOP')" disabled>â¸ æš‚åœ</button>
            <button class="btn btn-outline" onclick="toggleDebug()">ğŸ›  è°ƒè¯•</button>
        </div>

        <div id="debugPanel" class="debug-panel">
            <div class="btn-group">
                <button class="btn btn-outline" onclick="sendCommand('CMD:SERVO_FWD')">â¬‡ è½ç¬”</button>
                <button class="btn btn-outline" onclick="sendCommand('CMD:SERVO_REV')">â¬† æŠ¬ç¬”</button>
            </div>
            <div style="margin-top:10px; font-size:0.8rem; color:#999;">UUID: ...34fb</div>
        </div>
    </div>

    <script>
        // --- ä¿®å¤ç‚¹ï¼šUUID å¿…é¡»ä¸ main.c ä¸­çš„å®šä¹‰å®Œå…¨ä¸€è‡´ ---
        // Cä»£ç ä¸­: uuid128[12] = 0x01ï¼Œå¯¹åº” UUID å­—ç¬¦ä¸²çš„å‰éƒ¨
        const SERVICE_UUID   = '000000ff-0000-1000-8000-00805f9b34fb';
        const CHAR_CMD_UUID  = '0000ff01-0000-1000-8000-00805f9b34fb'; // ä¿®å¤ï¼šä¹‹å‰æ˜¯ ...3401
        const CHAR_STAT_UUID = '0000ff02-0000-1000-8000-00805f9b34fb'; // ä¿®å¤ï¼šä¹‹å‰æ˜¯ ...3402
        
        let device, server, service, charCmd, charStat;
        let gcodeContent = "";
        let autoScale = 1.0;
        let canvas, ctx, width, height;
        let isConnected = false;
        let twinX = 0, twinY = 0;

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js').catch(console.error);
        }

        window.onload = () => {
            canvas = document.getElementById('preview');
            ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            width = rect.width;
            height = rect.height;
            resetCanvas();
        };

        async function toggleConnection() {
            if (isConnected) disconnectBLE();
            else connectBLE();
        }

        async function connectBLE() {
            updateStatus("æ­£åœ¨æœç´¢è®¾å¤‡...", "blue");
            try {
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_UUID] }],
                    optionalServices: [SERVICE_UUID]
                });

                device.addEventListener('gattserverdisconnected', onDisconnected);
                updateStatus("æ­£åœ¨è¿æ¥ GATT...", "blue");
                
                server = await device.gatt.connect();
                service = await server.getPrimaryService(SERVICE_UUID);
                
                // è·å–ç‰¹å¾å€¼ (è¿™é‡Œå¦‚æœ UUID ä¸å¯¹ä¼šæŠ¥é”™)
                try {
                    charCmd = await service.getCharacteristic(CHAR_CMD_UUID);
                    charStat = await service.getCharacteristic(CHAR_STAT_UUID);
                } catch (e) {
                    throw new Error("UUID ä¸åŒ¹é…ï¼Œè¯·æ£€æŸ¥å›ºä»¶ç‰ˆæœ¬ã€‚");
                }

                await charStat.startNotifications();
                charStat.addEventListener('characteristicvaluechanged', handleStatusUpdate);

                onConnected(); // è¿æ¥æˆåŠŸï¼Œæ¿€æ´»ç•Œé¢
            } catch (error) {
                console.error(error);
                // ä¿®å¤ï¼šé˜²æ­¢æ˜¾ç¤º undefined
                let msg = error.message || error.toString();
                if (msg.includes("User cancelled")) msg = "ç”¨æˆ·å–æ¶ˆæ“ä½œ";
                updateStatus("æœªè¿æ¥ï¼š" + msg, "red");
            }
        }

        function disconnectBLE() {
            if (device && device.gatt.connected) device.gatt.disconnect();
        }

        function onConnected() {
            isConnected = true;
            document.getElementById('connectionBadge').innerText = "å·²è¿æ¥";
            document.getElementById('connectionBadge').classList.add("connected");
            document.getElementById('connectBtn').innerText = "âŒ æ–­å¼€è¿æ¥";
            document.getElementById('connectBtn').classList.add("btn-outline");
            
            // æ¿€æ´»åŠ è½½æŒ‰é’®
            document.getElementById('loadBtn').disabled = false;
            if (gcodeContent) document.getElementById('uploadBtn').disabled = false;
            
            updateStatus("è®¾å¤‡å·²å°±ç»ª", "green");
            twinX = 0; twinY = 0;
        }

        function onDisconnected() {
            isConnected = false;
            document.getElementById('connectionBadge').innerText = "æœªè¿æ¥";
            document.getElementById('connectionBadge').classList.remove("connected");
            document.getElementById('connectBtn').innerText = "ğŸ“¡ è¿æ¥è“ç‰™è®¾å¤‡";
            document.getElementById('connectBtn').classList.remove("btn-outline");
            document.getElementById('loadBtn').disabled = true;
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            updateStatus("è®¾å¤‡å·²æ–­å¼€", "orange");
        }

        async function handleFileSelect(file) {
            if (!file) return;
            const text = await file.text();
            gcodeContent = text;
            calculateScale(text);
            resetCanvas();
            drawPreview(text, '#e0e0e0');
            
            // åªæœ‰è¿æ¥çŠ¶æ€ä¸‹æ‰å…è®¸ä¸Šä¼ 
            document.getElementById('uploadBtn').disabled = !isConnected;
            updateStatus(`å·²åŠ è½½: ${file.name} (${(file.size/1024).toFixed(1)}KB)`, "black");
        }

        async function startUploadAndPrint() {
            if (!gcodeContent || !charCmd) return;

            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('progressContainer').style.display = 'block';
            
            try {
                updateStatus("æ­£åœ¨åˆå§‹åŒ–...", "blue");
                await sendCommand("CMD:NEWFILE");

                const lines = gcodeContent.split('\n');
                const total = lines.length;
                
                for (let i = 0; i < total; i++) {
                    const line = lines[i].trim();
                    if (line.length === 0 || line.startsWith(';')) continue;
                    
                    await sendCommand(line + "\n");
                    
                    if (i % 20 === 0) {
                        const pct = Math.round((i / total) * 100);
                        document.getElementById('progressFill').style.width = pct + "%";
                        updateStatus(`ä¸Šä¼ ä¸­... ${pct}%`, "blue");
                        await new Promise(r => setTimeout(r, 10));
                    }
                }
                
                updateStatus("å‘é€å¯åŠ¨æŒ‡ä»¤...", "blue");
                await sendCommand("CMD:START");
                
            } catch (e) {
                updateStatus("ä¸Šä¼ ä¸­æ–­: " + e.message, "red");
                document.getElementById('uploadBtn').disabled = false;
            }
        }

        async function sendCommand(cmd) {
            if (!charCmd) return;
            const encoder = new TextEncoder();
            await charCmd.writeValue(encoder.encode(cmd));
        }

        function handleStatusUpdate(event) {
            const value = event.target.value;
            const decoder = new TextDecoder();
            const jsonStr = decoder.decode(value);
            
            try {
                const data = JSON.parse(jsonStr);
                if (data.s === 1) {
                    updateStatus(`æ­£åœ¨ç»˜åˆ¶: ${data.p}%`, "green");
                    document.getElementById('progressFill').style.width = data.p + "%";
                } else if (data.s === 3) {
                    updateStatus("ç»˜åˆ¶å®Œæˆ! ğŸ‰", "green");
                    document.getElementById('uploadBtn').disabled = false;
                }
                if (data.c) drawTwinPath(data.c);
            } catch (e) {
                console.warn("JSON Error");
            }
        }

        function resetCanvas() {
            ctx.clearRect(0, 0, width, height);
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
        }

        function calculateScale(text) {
            let maxX = 0, maxY = 0;
            text.split('\n').forEach(line => {
                const x = line.match(/X([\d.]+)/);
                const y = line.match(/Y([\d.]+)/);
                if (x) maxX = Math.max(maxX, parseFloat(x[1]));
                if (y) maxY = Math.max(maxY, parseFloat(y[1]));
            });
            const padding = 20;
            const availW = width - padding * 2;
            const availH = height - padding * 2;
            if (maxX > 0 && maxY > 0) {
                autoScale = Math.min(availW / maxX, availH / maxY);
            } else {
                autoScale = 1.0;
            }
        }

        function drawPreview(text, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            let curX = 0, curY = 0;
            let isDown = false;

            text.split('\n').forEach(line => {
                if (line.includes('M3')) isDown = true;
                if (line.includes('M5')) isDown = false;
                const xMatch = line.match(/X([\d.]+)/);
                const yMatch = line.match(/Y([\d.]+)/);
                if (xMatch) curX = parseFloat(xMatch[1]) * autoScale;
                if (yMatch) curY = parseFloat(yMatch[1]) * autoScale;
                const drawX = curX + 10;
                const drawY = height - (curY + 10);

                if (line.includes('G0') || line.includes('G1')) {
                    if (isDown) ctx.lineTo(drawX, drawY);
                    else ctx.moveTo(drawX, drawY);
                }
            });
            ctx.stroke();
        }

        function drawTwinPath(cmd) {
            if (!cmd.includes('G1') && !cmd.includes('G0')) return;
            const xMatch = cmd.match(/X([\d.]+)/);
            const yMatch = cmd.match(/Y([\d.]+)/);
            if (!xMatch && !yMatch) return;

            let newX = twinX, newY = twinY;
            if (xMatch) newX = parseFloat(xMatch[1]) * autoScale;
            if (yMatch) newY = parseFloat(yMatch[1]) * autoScale;

            const startX = twinX + 10;
            const startY = height - (twinY + 10);
            const endX = newX + 10;
            const endY = height - (newY + 10);

            ctx.beginPath();
            ctx.strokeStyle = '#007AFF';
            ctx.lineWidth = 2;
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            twinX = newX; twinY = newY;
        }

        function updateStatus(msg, color="black") {
            const el = document.getElementById('status');
            el.innerText = msg;
            el.style.color = color;
        }

        function toggleDebug() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        }
    </script>
</body>
</html>