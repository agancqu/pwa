<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <title>Robot Studio BLE 5.0 (Layout Final)</title>
    <style>
        /* --- æ ¸å¿ƒåŸºç¡€æ ·å¼ --- */
        :root {
            --primary: #007AFF;
            --primary-dark: #0056b3;
            --success: #34C759;
            --success-dark: #248a3d;
            --danger: #FF3B30;
            --danger-dark: #cc2f26;
            --bg-color: #F2F2F7;
            --card-bg: #FFFFFF;
            --text-main: #1C1C1E;
            --text-sub: #8E8E93;
            --border-radius: 16px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            /* [ä¿®å¤] ç‰ˆæƒç¦»åº•è·ç¦»å‡å°ä¸€å€ (åŸ40px -> 20px) */
            padding-bottom: 20px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- å¸ƒå±€å·¥å…·ç±» --- */
        .max-w-md { max-width: 480px; margin: 0 auto; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .p-4 { padding: 1rem; }
        .p-3 { padding: 0.75rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-3 { margin-bottom: 0.75rem; }
        .mb-4 { margin-bottom: 1rem; }
        /* [ä¿®å¤] æŒ‰é’®ä¸åº•éƒ¨é—´è·å¢åŠ 2å€ (åŸmb-6 -> mb-12) */
        .mb-12 { margin-bottom: 3rem; }
        .pb-2 { padding-bottom: 0.5rem; } /* ç‰ˆæƒæ–‡å­—paddingå‡å° */
        
        .mt-2 { margin-top: 0.5rem; }
        .space-y-4 > * + * { margin-top: 1rem; }
        
        .relative { position: relative; }
        .absolute { position: absolute; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .z-10 { z-index: 10; }
        .opacity-0 { opacity: 0; cursor: pointer; } 
        
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .justify-center { justify-content: center; }
        .gap-1 { gap: 0.25rem; }
        .gap-2 { gap: 0.5rem; }
        .gap-3 { gap: 0.75rem; }
        .gap-4 { gap: 1rem; }
        .grid { display: grid; }
        .grid-cols-2 { grid-template-columns: 1fr 1fr; }
        .col-span-2 { grid-column: span 2; }

        .text-center { text-align: center; }
        .text-xs { font-size: 0.75rem; color: var(--text-sub); }
        .text-sm { font-size: 0.9rem; }
        .text-lg { font-size: 1.125rem; font-weight: 700; }
        .font-bold { font-weight: 600; }
        .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* å¡ç‰‡æ ·å¼ */
        .card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            padding: 1.25rem;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .navbar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 50;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 0; 
        }

        /* çŠ¶æ€æ  */
        #status {
            font-size: 0.95rem; 
            font-weight: 600;
            color: var(--text-main);
            padding: 8px 12px;
            border-radius: 8px;
            margin: 8px auto;
            transition: all 0.5s ease;
        }

        @keyframes breathe {
            0% { background-color: #E0F2FE; } 
            50% { background-color: #DCFCE7; } 
            100% { background-color: #E0F2FE; }
        }
        .status-breathing {
            animation: breathe 3s infinite ease-in-out;
            color: #000 !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        /* é«˜çº§å‚æ•°æŒ‰é’® */
        .advanced-summary {
            padding: 1.0rem 1rem; 
            font-size: 1.1rem;    
            font-weight: 600;
            color: var(--text-main);
            background-color: #F9FAFB;
            cursor: pointer;
            list-style: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px;
            border: 1px solid #E5E5EA;
            transition: background-color 0.2s;
        }
        .advanced-summary:active { background-color: #F3F4F6; }
        .advanced-summary::-webkit-details-marker { display: none; }
        .summary-arrow {
            font-size: 1.2em; 
            transition: transform 0.3s;
            color: var(--text-sub);
        }
        details[open] .summary-arrow { transform: rotate(180deg); }

        /* æŒ‰é’®æ ·å¼ */
        .btn {
            width: 100%;
            padding: 14px 20px;
            border-radius: 12px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        .btn:active { transform: scale(0.97); }
        .btn:disabled { background-color: #E5E5EA !important; color: #8E8E93 !important; cursor: not-allowed; box-shadow: none; }

        .btn-primary { background-color: var(--primary); }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-dark); }
        .btn-success { background-color: var(--success); }
        .btn-success:hover:not(:disabled) { background-color: var(--success-dark); }
        .btn-danger { background-color: var(--danger); }
        .btn-danger:hover:not(:disabled) { background-color: var(--danger-dark); }

        .btn-outline {
            background-color: transparent;
            border: 2px solid #E5E5EA;
            color: var(--primary);
            box-shadow: none;
            padding: 8px 12px;
            font-size: 0.85rem;
        }

        .upload-area {
            background-color: #F2F2F7;
            border: 2px dashed #C7C7CC;
            border-radius: 12px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .upload-area:active { background-color: #E5E5EA; }
        .upload-icon { font-size: 1.2rem; }
        .upload-text { font-size: 0.9rem; font-weight: 500; color: var(--text-main); }
        .upload-sub { font-size: 0.75rem; color: var(--text-sub); }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #ffffff;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .hidden { display: none !important; }

        canvas { display: block; image-rendering: pixelated; }
        
        .ratio-container {
            width: 100%;
            position: relative;
            background: #fff;
            border-radius: 12px;
            border: 1px solid #E5E5EA;
            overflow: hidden;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.05);
            padding-top: 100%; 
            transition: padding-top 0.3s ease;
        }

        .checkerboard-bg {
            background-image: 
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .fill-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* å…¨å±æ¨¡æ€ */
        .fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            cursor: zoom-out;
            animation: fadeIn 0.2s ease;
        }
        .fullscreen-modal canvas {
            max-width: 95vw;
            max-height: 95vh;
            width: auto !important;
            height: auto !important;
            object-fit: contain; 
            margin: auto; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .progress-track { background: #E5E5EA; border-radius: 10px; height: 8px; overflow: hidden; margin: 10px 0; }
        .progress-fill { background: var(--primary); height: 100%; width: 0%; transition: width 0.2s; }

        input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #E5E5EA; border-radius: 3px; outline: none; margin: 10px 0; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: white; box-shadow: 0 2px 6px rgba(0,0,0,0.2); border-radius: 50%; cursor: pointer; }
        input[type="checkbox"] { width: 20px; height: 20px; accent-color: var(--primary); }
    </style>
</head>
<body>

    <div class="navbar px-4 py-3 mb-4">
        <div class="max-w-md flex justify-between items-center mb-2">
            <h1 class="text-lg text-main flex items-center gap-2">ğŸ¨ Robot Studio</h1>
            <button id="connectBtn" onclick="toggleConnection()" class="btn-outline" style="width: auto; border-radius: 18px;">
                <span id="btIcon">ğŸ“¡</span> <span id="btText">æœªè¿æ¥</span>
            </button>
        </div>
        <div id="status" class="max-w-md text-center truncate">å‡†å¤‡å°±ç»ª</div>
    </div>

    <div class="max-w-md px-4">

        <div class="card">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-sm font-bold text-sub uppercase">STEP 1. åˆ¶ä½œ G-Code</h2>
            </div>
            
            <div class="relative upload-area mb-4">
                <input type="file" id="imageInput" accept="image/*" class="absolute inset-0 w-full h-full z-10 opacity-0">
                <span class="upload-icon">ğŸ“¸</span>
                <span class="upload-text">ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</span>
                <span class="upload-sub">(æ”¯æŒæ‹ç…§/ç›¸å†Œ)</span>
            </div>

            <details class="mb-4">
                <summary class="advanced-summary">
                    <span>âš™ï¸ é«˜çº§å‚æ•°è®¾ç½®</span>
                    <span class="summary-arrow">â–¼</span>
                </summary>
                <div class="p-3 pt-4 space-y-4 bg-gray-50 rounded-b-xl border-x border-b border-gray-200">
                    <div class="flex items-center justify-between">
                        <label class="text-sm">ä¿®å¤å®å¿ƒåŒºåŸŸ (ç©ºå¿ƒåŒ–)</label>
                        <input type="checkbox" id="hollowSolids" checked>
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>çº¿æ¡é˜ˆå€¼</span><span id="thresholdVal">128</span></div>
                        <input type="range" id="threshold" min="0" max="255" value="128">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>è·¯å¾„å¹³æ»‘ (æ‹–åŠ¨ç”Ÿæ•ˆ)</span><span id="smoothingVal">2.0</span></div>
                        <input type="range" id="smoothing" min="0" max="10" step="0.5" value="2.0">
                    </div>
                </div>
            </details>

            <div id="imgContainer" class="ratio-container checkerboard-bg mb-4">
                <canvas id="imgCanvas" class="fill-canvas"></canvas>
                <div id="imgPlaceholder" class="absolute inset-0 flex items-center justify-center text-xs text-sub pointer-events-none">å›¾ç‰‡é¢„è§ˆ</div>
            </div>

            <button id="processBtn" onclick="processImage()" class="btn btn-primary" disabled>
                <span id="loader" class="loader hidden"></span>
                <span id="processBtnText">âœ¨ è½¬æ¢å›¾ç‰‡ä¸ºè·¯å¾„</span>
            </button>
            <div id="pathStats" class="text-center text-xs mt-2" style="min-height: 1rem;"></div>
        </div>

        <div class="card">
            <h2 class="text-sm font-bold text-sub uppercase mb-3">STEP 2. ç»˜ç”»æ§åˆ¶</h2>
            
            <div class="progress-track">
                <div id="progressFill" class="progress-fill"></div>
            </div>

            <div class="grid grid-cols-2 gap-3 mb-4">
                <button id="uploadBtn" onclick="startUploadAndPrint()" class="btn btn-primary col-span-2" disabled>
                    ğŸ“¡ å‘é€ä»»åŠ¡
                </button>
                <button id="controlBtn" onclick="toggleDrawing()" class="btn btn-success col-span-2 hidden">
                    â–¶ å¼€å§‹ç»˜ç”»
                </button>
            </div>

            <div id="twinContainer" class="ratio-container">
                <canvas id="twinCanvas" class="fill-canvas"></canvas>
                <div class="absolute bottom-2 right-2 text-xs text-sub pointer-events-none">Digital Twin</div>
            </div>
        </div>

        <div class="flex justify-center mb-2">
            <button onclick="toggleDebug()" class="text-xs text-sub underline opacity-50 hover:opacity-100 bg-transparent border-none cursor-pointer">
                ğŸ›  æ‰“å¼€è°ƒè¯•é¢æ¿
            </button>
        </div>

        <div id="debugPanel" class="hidden bg-white shadow-sm p-4 rounded-xl border border-gray-200 mb-6 mx-auto max-w-md">
            <div class="flex items-center justify-between mb-3 pb-2 border-b border-gray-200">
                <span class="text-xs font-bold text-sub">è°ƒè¯•æ§åˆ¶</span>
                <label class="flex items-center gap-1 cursor-pointer text-xs text-blue-600">
                    <input type="checkbox" id="turboToggle" onchange="toggleTurbo()">
                    ğŸš€ æé€Ÿä»¿çœŸ
                </label>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <button class="btn-outline" onclick="sendCommand('CMD:SERVO_FWD')">â¬‡ è½ç¬”</button>
                <button class="btn-outline" onclick="sendCommand('CMD:SERVO_REV')">â¬† æŠ¬ç¬”</button>
            </div>
            <div class="mt-2 text-xs text-gray-400 text-center break-all">
                UUID: ...34fb
            </div>
        </div>

        <div class="text-center text-xs text-sub pb-2">Robot Studio BLE 5.0</div>
    </div>

    <div id="fullscreenModal" class="fullscreen-modal hidden" onclick="toggleFullscreen(false)">
    </div>

    <script>
        // --- å…¨å±€é…ç½® ---
        const SERVICE_UUID   = '000000ff-0000-1000-8000-00805f9b34fb';
        const CHAR_CMD_UUID  = '0000ff01-0000-1000-8000-00805f9b34fb';
        const CHAR_STAT_UUID = '0000ff02-0000-1000-8000-00805f9b34fb';
        
        let device, charCmd, charStat;
        let isConnected = false;
        
        let originalImage = null, binaryData = null;
        let rawPaths = [], optimizedPaths = [];
        let generatedGcode = ""; 
        let imgWidth = 0, imgHeight = 0;
        
        let allParsedLines = [], lastDrawnIndex = 0;
        let isM3Mode = true, autoScale = 1.0;
        
        const imgCanvas = document.getElementById('imgCanvas');
        const imgCtx = imgCanvas.getContext('2d');
        const twinCanvas = document.getElementById('twinCanvas');
        const twinCtx = twinCanvas.getContext('2d');

        if ('serviceWorker' in navigator) {
            if (window.location.protocol.startsWith('http')) {
                navigator.serviceWorker.register('service-worker.js').catch(console.error);
            }
        }

        window.onload = () => {
            resizeTwinCanvas();
            window.addEventListener('resize', resizeTwinCanvas);
        };

        // --- å…¨å±é€»è¾‘ ---
        const fullscreenModal = document.getElementById('fullscreenModal');
        const imgContainer = document.getElementById('imgContainer');
        let isFullscreen = false;

        imgCanvas.addEventListener('click', () => {
            if (originalImage && !isFullscreen) toggleFullscreen(true);
        });

        function toggleFullscreen(show) {
            isFullscreen = show;
            if (show) {
                fullscreenModal.classList.remove('hidden');
                fullscreenModal.appendChild(imgCanvas);
            } else {
                fullscreenModal.classList.add('hidden');
                imgContainer.appendChild(imgCanvas);
            }
        }

        function resizeTwinCanvas() {
            const container = isFullscreen ? fullscreenModal : imgContainer;
            const rect = document.getElementById('twinContainer').getBoundingClientRect();
            
            const dpr = window.devicePixelRatio || 1;
            twinCanvas.width = rect.width * dpr;
            twinCanvas.height = rect.height * dpr;
            twinCtx.scale(dpr, dpr);
            twinCanvas.logicalWidth = rect.width;
            twinCanvas.logicalHeight = rect.height;
            
            if(generatedGcode) drawTwinPreview(generatedGcode, '#e0e0e0');
        }

        // --- è“ç‰™é€»è¾‘ ---
        async function toggleConnection() {
            if (isConnected) disconnectBLE(); else connectBLE();
        }

        async function connectBLE() {
            if (!navigator.bluetooth) {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (isIOS) alert("iOSè¯·ä½¿ç”¨ Bluefy æµè§ˆå™¨");
                else updateStatus("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒè“ç‰™", "red");
                return;
            }
            updateStatus("æ­£åœ¨æœç´¢...", "blue");
            try {
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_UUID] }],
                    optionalServices: [SERVICE_UUID]
                });
                device.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                charCmd = await service.getCharacteristic(CHAR_CMD_UUID);
                charStat = await service.getCharacteristic(CHAR_STAT_UUID);
                await charStat.startNotifications();
                charStat.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                onConnected();
            } catch (e) {
                if(!e.message.includes("cancelled")) updateStatus("è¿æ¥å¤±è´¥: " + e.message, "red");
            }
        }

        function disconnectBLE() {
            if (device && device.gatt.connected) device.gatt.disconnect();
        }

        function onConnected() {
            isConnected = true;
            document.getElementById('btText').innerText = "å·²è¿æ¥";
            document.getElementById('btIcon').innerText = "âœ…";
            const btn = document.getElementById('connectBtn');
            btn.style.borderColor = "var(--success)";
            btn.style.color = "var(--success)";
            updateStatus("è®¾å¤‡å·²å°±ç»ª", "green");
            toggleTurbo();
            if (generatedGcode) document.getElementById('uploadBtn').disabled = false;
        }

        function onDisconnected() {
            isConnected = false;
            document.getElementById('btText').innerText = "è¿æ¥è®¾å¤‡";
            document.getElementById('btIcon').innerText = "ğŸ“¡";
            const btn = document.getElementById('connectBtn');
            btn.style.borderColor = "#E5E5EA";
            btn.style.color = "var(--primary)";
            
            setBreathing(false);
            
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('controlBtn').classList.add('hidden');
            document.getElementById('uploadBtn').classList.remove('hidden');
            updateStatus("è®¾å¤‡å·²æ–­å¼€", "red");
        }

        // --- å›¾åƒå¤„ç† ---
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt) {
                const img = new Image();
                img.onload = function() {
                    resetUIForNewImage();

                    const maxSize = 800;
                    let w = img.width, h = img.height;
                    if (w > maxSize || h > maxSize) {
                        const ratio = Math.min(maxSize / w, maxSize / h);
                        w = Math.round(w * ratio); h = Math.round(h * ratio);
                    }
                    imgWidth = w; imgHeight = h;
                    
                    const aspectRatio = (h / w) * 100 + "%";
                    document.getElementById('imgContainer').style.paddingTop = aspectRatio;
                    document.getElementById('twinContainer').style.paddingTop = aspectRatio;

                    imgCanvas.width = w; imgCanvas.height = h;
                    imgCtx.drawImage(img, 0, 0, w, h);
                    originalImage = imgCtx.getImageData(0, 0, w, h);
                    
                    document.getElementById('imgPlaceholder').style.display = 'none';
                    
                    const pBtn = document.getElementById('processBtn');
                    pBtn.disabled = false;
                    pBtn.classList.remove('btn-success');
                    pBtn.classList.add('btn-primary');
                    document.getElementById('processBtnText').innerText = "âœ¨ è½¬æ¢å›¾ç‰‡ä¸ºè·¯å¾„";
                    
                    document.getElementById('pathStats').innerText = `å›¾ç‰‡: ${w}x${h}px`;
                    generatedGcode = "";
                    rawPaths = []; 
                    
                    document.getElementById('uploadBtn').disabled = true;
                    updateBinaryPreview();
                    
                    setTimeout(resizeTwinCanvas, 100);
                }
                img.src = evt.target.result;
            }
            reader.readAsDataURL(file);
        });

        function resetUIForNewImage() {
            document.getElementById('controlBtn').classList.add('hidden'); 
            document.getElementById('uploadBtn').classList.remove('hidden'); 
            document.getElementById('uploadBtn').disabled = true; 
            document.getElementById('uploadBtn').innerText = "ğŸ“¡ å‘é€ä»»åŠ¡"; 
            document.getElementById('progressFill').style.width = "0%"; 
            setBreathing(false); 
            updateStatus("å›¾ç‰‡å·²åŠ è½½", "black");
        }

        document.getElementById('threshold').addEventListener('input', (e) => {
            document.getElementById('thresholdVal').innerText = e.target.value;
            if(originalImage) updateBinaryPreview();
        });

        document.getElementById('smoothing').addEventListener('input', (e) => {
            document.getElementById('smoothingVal').innerText = e.target.value;
            if(rawPaths && rawPaths.length > 0) {
                updatePathsAndGcode();
            }
        });

        function updateBinaryPreview() {
            if(!originalImage) return;
            const th = parseInt(document.getElementById('threshold').value);
            const output = imgCtx.createImageData(imgWidth, imgHeight);
            const d = originalImage.data; const out = output.data;
            for(let i=0; i<d.length; i+=4) {
                const gray = 0.34*d[i] + 0.5*d[i+1] + 0.16*d[i+2];
                const val = gray < th ? 0 : 255;
                out[i]=out[i+1]=out[i+2]=val; out[i+3]=255;
            }
            imgCtx.putImageData(output, 0, 0);
        }

        async function processImage() {
            if(!originalImage) return;
            const btn = document.getElementById('processBtn');
            const loader = document.getElementById('loader');
            const txt = document.getElementById('processBtnText');
            
            btn.disabled = true;
            loader.classList.remove('hidden');
            txt.innerText = "æ­£åœ¨è¿ç®—...";
            
            setTimeout(() => {
                try {
                    const th = parseInt(document.getElementById('threshold').value);
                    const hollow = document.getElementById('hollowSolids').checked;

                    prepareBinaryData(th);
                    if(hollow) hollowSolids();
                    skeletonize();
                    tracePaths();
                    
                    updatePathsAndGcode();
                    
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-success');
                    updateStatus("è½¬æ¢æˆåŠŸï¼Œå‡†å¤‡å‘é€", "green");

                } catch(e) {
                    console.error(e);
                    updateStatus("ç®—æ³•é”™è¯¯", "red");
                } finally {
                    btn.disabled = false;
                    loader.classList.add('hidden');
                    txt.innerText = "âœ¨ è½¬æ¢å®Œæˆ";
                }
            }, 50);
        }

        function updatePathsAndGcode() {
            const sm = parseFloat(document.getElementById('smoothing').value);
            const sorted = sortAndMergePaths(rawPaths);
            optimizedPaths = sorted.map(p => simplifyPathRDP(p, sm));
            generateGcodeInternal();
            const pts = optimizedPaths.reduce((a,p)=>a+p.length,0);
            document.getElementById('pathStats').innerText = `è·¯å¾„: ${optimizedPaths.length} | èŠ‚ç‚¹: ${pts}`;
            resizeTwinCanvas();
            if(isConnected) document.getElementById('uploadBtn').disabled = false;
        }

        // --- æ ¸å¿ƒç®—æ³• ---
        function prepareBinaryData(th) {
            binaryData = new Int8Array(imgWidth*imgHeight);
            const d = originalImage.data;
            for(let i=0; i<imgWidth*imgHeight; i++) {
                const val = (0.34*d[i*4]+0.5*d[i*4+1]+0.16*d[i*4+2]);
                binaryData[i] = val < th ? 1 : 0;
            }
        }
        function getPixel(x,y){ if(x<0||x>=imgWidth||y<0||y>=imgHeight)return 0; return binaryData[y*imgWidth+x]; }
        
        function hollowSolids() {
            const t = new Int8Array(binaryData);
            for(let y=1; y<imgHeight-1; y++) {
                for(let x=1; x<imgWidth-1; x++) {
                    const idx = y*imgWidth+x;
                    if(t[idx] && t[idx-1] && t[idx+1] && t[idx-imgWidth] && t[idx+imgWidth]) binaryData[idx]=0;
                }
            }
        }

        function skeletonize() {
            let changed=true; const rem=[];
            while(changed) {
                changed=false;
                for(let pass=0; pass<2; pass++) {
                    rem.length=0;
                    for(let y=1; y<imgHeight-1; y++){
                        for(let x=1; x<imgWidth-1; x++){
                            if(getPixel(x,y)){
                                const p2=getPixel(x,y-1), p3=getPixel(x+1,y-1), p4=getPixel(x+1,y);
                                const p5=getPixel(x+1,y+1), p6=getPixel(x,y+1), p7=getPixel(x-1,y+1);
                                const p8=getPixel(x-1,y), p9=getPixel(x-1,y-1);
                                const A = (p2==0&&p3==1)+(p3==0&&p4==1)+(p4==0&&p5==1)+(p5==0&&p6==1)+(p6==0&&p7==1)+(p7==0&&p8==1)+(p8==0&&p9==1)+(p9==0&&p2==1);
                                const B = p2+p3+p4+p5+p6+p7+p8+p9;
                                const m1 = pass==0 ? (p2*p4*p6) : (p2*p4*p8);
                                const m2 = pass==0 ? (p4*p6*p8) : (p2*p6*p8);
                                if(A==1 && B>=2 && B<=6 && m1==0 && m2==0) rem.push(y*imgWidth+x);
                            }
                        }
                    }
                    if(rem.length>0){ changed=true; for(let i=0; i<rem.length; i++) binaryData[rem[i]]=0; }
                }
            }
        }

        function tracePaths() {
            rawPaths=[]; const visited=new Int8Array(imgWidth*imgHeight);
            for(let y=0; y<imgHeight; y++){
                for(let x=0; x<imgWidth; x++){
                    const idx=y*imgWidth+x;
                    if(binaryData[idx] && !visited[idx]) {
                        let path=[]; let cx=x, cy=y;
                        while(true) {
                            path.push({x:cx,y:cy}); visited[cy*imgWidth+cx]=1; let found=false;
                            const ns=[{dx:1,dy:0},{dx:1,dy:1},{dx:0,dy:1},{dx:-1,dy:1},{dx:-1,dy:0},{dx:-1,dy:-1},{dx:0,dy:-1},{dx:1,dy:-1}];
                            for(let n of ns) {
                                const nx=cx+n.dx, ny=cy+n.dy;
                                if(nx>=0&&nx<imgWidth&&ny>=0&&ny<imgHeight) {
                                    if(binaryData[ny*imgWidth+nx] && !visited[ny*imgWidth+nx]) { cx=nx; cy=ny; found=true; break; }
                                }
                            }
                            if(!found) break;
                        }
                        if(path.length>2) rawPaths.push(path);
                    }
                }
            }
        }

        function sortAndMergePaths(paths) {
            if(paths.length===0) return [];
            let rem = paths.map(p=>[...p]), sorted = [], curr = rem.shift();
            while(true) {
                let best=-1, minD=Infinity, rev=false, tip=curr[curr.length-1];
                for(let i=0; i<rem.length; i++) {
                    const start=rem[i][0], end=rem[i][rem[i].length-1];
                    const d1=(tip.x-start.x)**2+(tip.y-start.y)**2;
                    const d2=(tip.x-end.x)**2+(tip.y-end.y)**2;
                    if(d1<minD){minD=d1; best=i; rev=false;}
                    if(d2<minD){minD=d2; best=i; rev=true;}
                }
                if(best===-1) {
                    sorted.push(curr);
                    if(rem.length>0) { curr=rem.shift(); continue; } else break;
                }
                if(minD<=5) {
                    const next=rem[best]; if(rev) next.reverse();
                    curr.push(...next); rem.splice(best,1);
                } else {
                    sorted.push(curr);
                    const next=rem[best]; if(rev) next.reverse();
                    curr=next; rem.splice(best,1);
                }
            }
            return sorted;
        }

        function perpendicularDistance(p, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const lenSq = dx * dx + dy * dy;
            if (lenSq === 0) {
                return Math.sqrt((p.x - lineStart.x)**2 + (p.y - lineStart.y)**2);
            }
            let t = ((p.x - lineStart.x) * dx + (p.y - lineStart.y) * dy) / lenSq;
            if (t < 0) t = 0; else if (t > 1) t = 1;
            const projX = lineStart.x + t * dx;
            const projY = lineStart.y + t * dy;
            return Math.sqrt((p.x - projX)**2 + (p.y - projY)**2);
        }

        function simplifyPathRDP(path, epsilon) {
            if (path.length < 3) return path; 
            let dmax = 0;
            let index = 0;
            const end = path.length - 1;
            for (let i = 1; i < end; i++) {
                const d = perpendicularDistance(path[i], path[0], path[end]);
                if (d > dmax) {
                    index = i;
                    dmax = d;
                }
            }
            if (dmax > epsilon) {
                const results1 = simplifyPathRDP(path.slice(0, index + 1), epsilon);
                const results2 = simplifyPathRDP(path.slice(index, path.length), epsilon);
                return results1.slice(0, results1.length - 1).concat(results2);
            } else {
                return [path[0], path[end]];
            }
        }

        function generateGcodeInternal() {
            const WORK_WIDTH = 100.0; 
            const scale = WORK_WIDTH / Math.max(imgWidth, 1);
            let g = "G90\nM5\n";
            optimizedPaths.forEach(p => {
                if(p.length===0) return;
                const sx=(p[0].x*scale).toFixed(2), sy=((imgHeight-p[0].y)*scale).toFixed(2);
                g+=`G0 X${sx} Y${sy}\nM3 S1000\n`;
                for(let i=1; i<p.length; i++) {
                    const px=(p[i].x*scale).toFixed(2), py=((imgHeight-p[i].y)*scale).toFixed(2);
                    g+=`G1 X${px} Y${py}\n`;
                }
                g+=`M5\n`;
            });
            g+="G0 X0 Y0\n";
            generatedGcode = g;
            parseAllLines(g);
            drawTwinPreview(g, '#e0e0e0');
        }

        // --- ä¼ è¾“ ---
        async function startUploadAndPrint() {
            if(!generatedGcode || !charCmd) return;
            const btn = document.getElementById('uploadBtn');
            btn.disabled = true;
            btn.innerText = "â³ ä¼ è¾“ä¸­...";
            lastDrawnIndex = 0;
            
            // [Bug 2] å¼€å§‹å‘¼å¸
            setBreathing(true);
            
            try {
                updateStatus("æ­£åœ¨åˆå§‹åŒ–...", "blue");
                await sendCommand("CMD:NEWFILE");
                
                const lines = generatedGcode.split('\n');
                let chunk = ""; const CHUNK=150; 
                
                for(let i=0; i<lines.length; i++) {
                    let line = lines[i].trim();
                    if(!line) continue;
                    line += "\n";
                    if(chunk.length + line.length > CHUNK) {
                        await sendCommand(chunk);
                        chunk = "";
                        if(i%5===0) { 
                            const pct = Math.round((i/lines.length)*100);
                            document.getElementById('progressFill').style.width = pct+"%";
                            updateStatus(`ä¸Šä¼ ä¸­: ${pct}%`, "blue");
                            await new Promise(r=>setTimeout(r, 5));
                        }
                    }
                    chunk += line;
                }
                if(chunk) await sendCommand(chunk);
                
                document.getElementById('progressFill').style.width = "100%";
                updateStatus("ä¸Šä¼ å®Œæˆï¼Œè¯·å¼€å§‹", "green");
                
                btn.classList.add('hidden');
                document.getElementById('controlBtn').classList.remove('hidden');
                
            } catch(e) {
                updateStatus("ä¸Šä¼ å¤±è´¥", "red");
                setBreathing(false); // å¤±è´¥åœæ­¢
                btn.disabled = false;
                btn.innerText = "ğŸ“¡ é‡è¯•";
            }
        }

        // --- è¾…åŠ© ---
        function setBreathing(enable) {
            const st = document.getElementById('status');
            if(enable) st.classList.add('status-breathing');
            else st.classList.remove('status-breathing');
        }

        async function toggleDrawing() {
            const btn = document.getElementById('controlBtn');
            if(btn.innerText.includes("å¼€å§‹") || btn.innerText.includes("ç»§ç»­") || btn.innerText.includes("å†æ¬¡")) {
                await sendCommand("CMD:START");
                btn.innerText = "â¸ æš‚åœ";
                btn.className = "btn btn-danger col-span-2";
                updateStatus("ç»˜ç”»ä¸­...", "green");
                setBreathing(true); // [Bug 2] ç»˜ç”»ä¸­å‘¼å¸
            } else {
                await sendCommand("CMD:STOP");
                btn.innerText = "â–¶ ç»§ç»­";
                btn.className = "btn btn-success col-span-2";
                updateStatus("å·²æš‚åœ", "orange");
                setBreathing(false); // [Bug 2] æš‚åœåœæ­¢å‘¼å¸
            }
        }

        async function toggleTurbo() {
            if(!isConnected) return;
            const on = document.getElementById('turboToggle').checked;
            await sendCommand(on ? "CMD:TURBO_ON" : "CMD:TURBO_OFF");
        }

        async function sendCommand(cmd) {
            if(!charCmd) return;
            const enc = new TextEncoder();
            await charCmd.writeValue(enc.encode(cmd));
        }

        function handleStatusUpdate(e) {
            const val = e.target.value;
            const dec = new TextDecoder();
            const str = dec.decode(val);
            try {
                const d = JSON.parse(str);
                const btn = document.getElementById('controlBtn');
                
                if(d.s === 1) { // Running
                    if(!btn.innerText.includes("æš‚åœ")) {
                        btn.innerText = "â¸ æš‚åœ"; btn.className = "btn btn-danger col-span-2";
                        btn.disabled = false; btn.classList.remove('hidden');
                        document.getElementById('uploadBtn').classList.add('hidden');
                        setBreathing(true);
                    }
                    const total = allParsedLines.length;
                    const pct = total>0 ? Math.round((d.i/total)*100) : 0;
                    document.getElementById('progressFill').style.width = pct+"%";
                    updateStatus(`ç»˜ç”»ä¸­: ${pct}%`, "green");
                } else if(d.s === 2) { // Paused
                    if(!btn.innerText.includes("ç»§ç»­")) {
                        btn.innerText = "â–¶ ç»§ç»­"; btn.className = "btn btn-success col-span-2";
                        setBreathing(false);
                    }
                } else if(d.s === 3) { // Finished
                    updateStatus("å®Œæˆ! ğŸ‰", "green");
                    btn.innerText = "â–¶ å†æ¬¡ç»˜ç”»"; btn.className = "btn btn-success col-span-2";
                    setBreathing(false);
                }
                if(d.i > lastDrawnIndex) {
                    drawSegment(lastDrawnIndex, d.i);
                    lastDrawnIndex = d.i;
                }
            } catch(err){}
        }

        // --- å­ªç”Ÿç»˜å›¾ ---
        function parseAllLines(text) {
            allParsedLines = [];
            let cx=0, cy=0, down=false;
            
            const container = document.getElementById('twinContainer');
            const cw = container.clientWidth || 300;
            const ch = container.clientHeight || 300;
            
            const scale = (cw*0.9)/100.0, ox = cw*0.05, oy = ch*0.05;

            text.split('\n').forEach(l => {
                if(l.includes('M3')) down=true; if(l.includes('M5')) down=false;
                const zm = l.match(/Z([-\d.]+)/); if(zm) down=(parseFloat(zm[1])<=0);
                const xm = l.match(/X([-\d.]+)/), ym = l.match(/Y([-\d.]+)/);
                
                const gx = xm?parseFloat(xm[1]):cx;
                const gy = ym?parseFloat(ym[1]):cy;
                
                const tx = gx*scale + ox;
                const ty = ch - (gy*scale) - oy;
                
                allParsedLines.push({x:tx, y:ty, down:down, valid:(l.includes('G0')||l.includes('G1'))});
                if(xm) cx=gx; if(ym) cy=gy;
            });
        }

        function drawTwinPreview(txt, col) {
            twinCtx.clearRect(0,0,twinCanvas.width,twinCanvas.height);
            twinCtx.lineCap='round'; twinCtx.lineJoin='round';
            twinCtx.beginPath(); twinCtx.strokeStyle=col; twinCtx.lineWidth=1;
            if(allParsedLines.length===0) return;
            twinCtx.moveTo(allParsedLines[0].x, allParsedLines[0].y);
            for(let i=1; i<allParsedLines.length; i++) {
                const p = allParsedLines[i];
                if(p.valid) {
                    if(p.down) twinCtx.lineTo(p.x, p.y); else twinCtx.moveTo(p.x, p.y);
                }
            }
            twinCtx.stroke();
        }

        function drawSegment(start, end) {
            if(end>=allParsedLines.length) end=allParsedLines.length-1;
            twinCtx.beginPath(); twinCtx.strokeStyle='#007AFF'; twinCtx.lineWidth=2;
            let sp = allParsedLines[start]; if(!sp) return;
            twinCtx.moveTo(sp.x, sp.y);
            for(let i=start+1; i<=end; i++) {
                const p = allParsedLines[i];
                if(p.valid) {
                    if(p.down) twinCtx.lineTo(p.x, p.y); else twinCtx.moveTo(p.x, p.y);
                }
            }
            twinCtx.stroke();
        }

        function updateStatus(msg, color) {
            const el = document.getElementById('status');
            el.innerText = msg;
            if(color==='red') el.style.color = 'var(--danger)';
            else if(color==='green') el.style.color = 'var(--success)';
            else el.style.color = 'var(--text-sub)';
        }

        function toggleDebug() {
            const p = document.getElementById('debugPanel');
            p.classList.toggle('hidden');
        }
    </script>
</body>
</html>