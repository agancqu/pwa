<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Robot Studio BLE 7.3 (Full Fixed)</title>
    <style>
        /* --- æ ¸å¿ƒåŸºç¡€æ ·å¼ --- */
        :root {
            --primary: #007AFF;
            --primary-dark: #0056b3;
            --success: #34C759;
            --success-dark: #248a3d;
            --danger: #FF3B30;
            --danger-dark: #cc2f26;
            --bg-color: #F2F2F7;
            --card-bg: #FFFFFF;
            --text-main: #1C1C1E;
            --text-sub: #8E8E93;
            --border-radius: 16px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding-bottom: 20px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- å¸ƒå±€å·¥å…·ç±» --- */
        .max-w-md { max-width: 480px; margin: 0 auto; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .p-4 { padding: 1rem; }
        .p-3 { padding: 0.75rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-3 { margin-bottom: 0.75rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-12 { margin-bottom: 3rem; }
        
        .mt-2 { margin-top: 0.5rem; }
        .space-y-4 > * + * { margin-top: 1rem; }
        
        .relative { position: relative; }
        .absolute { position: absolute; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .z-10 { z-index: 10; }
        .opacity-0 { opacity: 0; cursor: pointer; } 
        
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .justify-center { justify-content: center; }
        .gap-2 { gap: 0.5rem; }
        .grid { display: grid; }
        .grid-cols-2 { grid-template-columns: 1fr 1fr; }
        .col-span-2 { grid-column: span 2; }

        .text-center { text-align: center; }
        .text-xs { font-size: 0.75rem; color: var(--text-sub); }
        .text-sm { font-size: 0.9rem; }
        .text-lg { font-size: 1.125rem; font-weight: 700; }
        .font-bold { font-weight: 600; }
        .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* å¡ç‰‡æ ·å¼ */
        .card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            padding: 1.25rem;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .navbar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 50;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        /* çŠ¶æ€æ  */
        #status {
            font-size: 0.95rem; 
            font-weight: 600;
            color: var(--text-main);
            padding: 8px 12px;
            border-radius: 8px;
            margin: 8px auto;
            transition: all 0.5s ease;
        }

        @keyframes breathe {
            0% { background-color: #E0F2FE; } 
            50% { background-color: #DCFCE7; } 
            100% { background-color: #E0F2FE; }
        }
        .status-breathing {
            animation: breathe 3s infinite ease-in-out;
            color: #000 !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        /* æŒ‰é’®æ ·å¼ */
        .btn {
            width: 100%;
            padding: 14px 20px;
            border-radius: 12px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        .btn:active { transform: scale(0.97); }
        .btn:disabled { background-color: #E5E5EA !important; color: #8E8E93 !important; cursor: not-allowed; box-shadow: none; }

        .btn-primary { background-color: var(--primary); }
        .btn-success { background-color: var(--success); }
        .btn-danger { background-color: var(--danger); }

        .btn-outline {
            background-color: transparent;
            border: 2px solid #E5E5EA;
            color: var(--primary);
            box-shadow: none;
            padding: 8px 12px;
            font-size: 0.85rem;
            width: 100%;
        }

        /* ä¸Šä¼ åŒºåŸŸ */
        .upload-area {
            background-color: #F2F2F7;
            border: 2px dashed #C7C7CC;
            border-radius: 12px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .upload-area:active { background-color: #E5E5EA; }
        .upload-icon { font-size: 1.2rem; }
        .upload-text { font-size: 0.9rem; font-weight: 500; color: var(--text-main); }
        .upload-sub { font-size: 0.75rem; color: var(--text-sub); }

        /* è¾…åŠ©ç»„ä»¶ */
        .loader {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #ffffff;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .hidden { display: none !important; }

        /* ç”»å¸ƒå®¹å™¨ */
        canvas { display: block; image-rendering: pixelated; width: 100%; height: 100%; }
        
        .ratio-container {
            width: 100%;
            position: relative;
            background: #fff;
            border-radius: 12px;
            border: 1px solid #E5E5EA;
            overflow: hidden;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.05);
            padding-top: 100%; 
        }

        .checkerboard-bg {
            background-image: 
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .fill-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* å…¨å±æ¨¡æ€ */
        .fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            cursor: zoom-out;
        }
        .fullscreen-modal canvas {
            max-width: 95vw;
            max-height: 95vh;
            width: auto !important;
            height: auto !important;
            object-fit: contain; 
        }

        /* è¿›åº¦æ¡ä¸æ»‘å— */
        .progress-track { background: #E5E5EA; border-radius: 10px; height: 8px; overflow: hidden; margin: 10px 0; }
        .progress-fill { background: var(--primary); height: 100%; width: 0%; transition: width 0.2s; }

        input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #E5E5EA; border-radius: 3px; outline: none; margin: 10px 0; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: white; box-shadow: 0 2px 6px rgba(0,0,0,0.2); border-radius: 50%; cursor: pointer; }
        
        /* æŠ˜å èœå• */
        .advanced-summary {
            padding: 1rem; 
            font-size: 0.95rem; font-weight: 600;
            background-color: #F9FAFB;
            cursor: pointer;
            list-style: none;
            display: flex; justify-content: space-between; align-items: center;
            border-radius: 12px; border: 1px solid #E5E5EA;
        }
        .advanced-summary::-webkit-details-marker { display: none; }
        .summary-arrow { transition: transform 0.3s; color: var(--text-sub); }
        details[open] .summary-arrow { transform: rotate(180deg); }

        /* å½•éŸ³çŠ¶æ€ç¯ */
        #recIndicator {
            width: 12px; height: 12px; border-radius: 50%;
            background-color: #ccc; margin-right: 5px;
            display: inline-block;
        }
        .recording-active {
            background-color: #FF3B30 !important;
            animation: blink 1s infinite;
        }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div class="navbar px-4 py-3 mb-4">
        <div class="max-w-md flex justify-between items-center mb-2">
            <h1 class="text-lg text-main flex items-center gap-2">ğŸ¤– Robot Studio 7.3</h1>
            <button id="connectBtn" onclick="toggleConnection()" class="btn-outline" style="width: auto; border-radius: 18px;">
                <span id="btIcon">ğŸ“¡</span> <span id="btText">æœªè¿æ¥</span>
            </button>
        </div>
        <div id="status" class="max-w-md text-center truncate">å‡†å¤‡å°±ç»ª (é•¿æŒ‰éŸ³é‡é”®å½•éŸ³)</div>
    </div>

    <div class="max-w-md px-4">

        <div class="card">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-sm font-bold text-sub uppercase">STEP 1. åˆ¶ä½œ G-Code</h2>
            </div>
            
            <div class="relative upload-area mb-4">
                <input type="file" id="imageInput" accept="image/*" class="absolute inset-0 w-full h-full z-10 opacity-0">
                <span class="upload-icon">ğŸ“¸</span>
                <span class="upload-text">ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</span>
                <span class="upload-sub">(æ”¯æŒæ‹ç…§/ç›¸å†Œ)</span>
            </div>

            <details class="mb-4">
                <summary class="advanced-summary">
                    <span>âš™ï¸ é«˜çº§å‚æ•°è®¾ç½®</span>
                    <span class="summary-arrow">â–¼</span>
                </summary>
                <div class="p-3 pt-4 space-y-4 bg-gray-50 rounded-b-xl border-x border-b border-gray-200">
                    <div class="flex items-center justify-between">
                        <label class="text-sm">ä¿®å¤å®å¿ƒåŒºåŸŸ (ç©ºå¿ƒåŒ–)</label>
                        <input type="checkbox" id="hollowSolids" checked>
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>çº¿æ¡é˜ˆå€¼</span><span id="thresholdVal">128</span></div>
                        <input type="range" id="threshold" min="0" max="255" value="128">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>è·¯å¾„å¹³æ»‘</span><span id="smoothingVal">2.0</span></div>
                        <input type="range" id="smoothing" min="0" max="10" step="0.5" value="2.0">
                    </div>
                </div>
            </details>

            <div id="imgContainer" class="ratio-container checkerboard-bg mb-4">
                <canvas id="imgCanvas" class="fill-canvas"></canvas>
                <div id="imgPlaceholder" class="absolute inset-0 flex items-center justify-center text-xs text-sub pointer-events-none">å›¾ç‰‡é¢„è§ˆ</div>
            </div>

            <button id="processBtn" onclick="processImage()" class="btn btn-primary" disabled>
                <span id="loader" class="loader hidden"></span>
                <span id="processBtnText">âœ¨ è½¬æ¢å›¾ç‰‡ä¸ºè·¯å¾„</span>
            </button>
            <div id="pathStats" class="text-center text-xs mt-2" style="min-height: 1rem;"></div>
        </div>

        <div class="card">
            <h2 class="text-sm font-bold text-sub uppercase mb-3">STEP 2. ç»˜ç”»æ§åˆ¶</h2>
            
            <div class="progress-track">
                <div id="progressFill" class="progress-fill"></div>
            </div>

            <div class="grid grid-cols-2 gap-3 mb-4">
                <button id="uploadBtn" onclick="startUploadAndPrint()" class="btn btn-primary col-span-2" disabled>
                    ğŸ“¡ å‘é€ä»»åŠ¡
                </button>
                <button id="controlBtn" onclick="toggleDrawing()" class="btn btn-success col-span-2 hidden">
                    â–¶ å¼€å§‹ç»˜ç”»
                </button>
            </div>

            <div id="twinContainer" class="ratio-container">
                <canvas id="twinCanvas" class="fill-canvas"></canvas>
                <div class="absolute bottom-2 right-2 text-xs text-sub pointer-events-none">Digital Twin</div>
            </div>
        </div>

        <div class="flex justify-center mb-12">
            <button onclick="toggleDebug()" class="text-xs text-sub underline opacity-50 hover:opacity-100 bg-transparent border-none cursor-pointer">
                ğŸ›  æ‰“å¼€è°ƒè¯•é¢æ¿
            </button>
        </div>

        <div id="debugPanel" class="hidden bg-white shadow-sm p-4 rounded-xl border border-gray-200 mb-6 mx-auto max-w-md">
            <div class="flex items-center justify-between mb-3 pb-2 border-b border-gray-200">
                <div class="flex items-center">
                    <span id="recIndicator"></span>
                    <span class="text-xs font-bold text-sub">å½•éŸ³çŠ¶æ€</span>
                </div>
                <div class="text-xs text-gray-500" id="audioStats">æ— æ•°æ®</div>
            </div>

            <div class="flex items-center justify-between mb-3 pb-2 border-b border-gray-200">
                <span class="text-xs font-bold text-sub">è°ƒè¯•æ§åˆ¶</span>
                <label class="flex items-center gap-1 cursor-pointer text-xs text-blue-600">
                    <input type="checkbox" id="turboToggle" onchange="toggleTurbo()">
                    ğŸš€ æé€Ÿä»¿çœŸ
                </label>
            </div>
            
            <div class="grid grid-cols-2 gap-2 mb-2">
                <button class="btn-outline" onclick="sendCommand('CMD:SERVO_FWD')">â¬‡ è½ç¬”</button>
                <button class="btn-outline" onclick="sendCommand('CMD:SERVO_REV')">â¬† æŠ¬ç¬”</button>
            </div>
            
            <div class="grid grid-cols-2 gap-2">
                <button class="btn-outline" onclick="sendCommand('CMD:HOME')">ğŸ  å½’ä½æ ¡å‡†</button>
                <div style="display: flex; gap: 5px;">
                    <input type="number" id="testTrackInput" value="1" min="1" max="255" style="width: 40px; text-align: center; border: 1px solid #E5E5EA; border-radius: 8px; background: transparent; color: var(--primary); outline: none;">
                    <button class="btn-outline" style="flex: 1;" onclick="sendTestAudio()">ğŸ”Š æµ‹è¯•</button>
                </div>
            </div>

            <button id="playRecBtn" onclick="playLastRecording()" class="btn btn-primary mt-3" disabled>
                â–¶ï¸ æ’­æ”¾æœ€è¿‘å½•éŸ³
            </button>

            <div class="mt-2 text-xs text-gray-400 text-center break-all">
                UUID: ...ee...34fb
            </div>
        </div>

        <div class="text-center text-xs text-sub pb-2">Robot Studio BLE 7.3</div>
    </div>

    <div id="fullscreenModal" class="fullscreen-modal hidden" onclick="toggleFullscreen(false)">
    </div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        // [ä¿®å¤ 1] UUID æ›´æ–°ä¸º EEï¼Œå¼ºåˆ¶åˆ·æ–°ç¼“å­˜
        const SERVICE_UUID    = '000000ee-0000-1000-8000-00805f9b34fb';
        
        const CHAR_CMD_UUID   = '0000ff01-0000-1000-8000-00805f9b34fb';
        const CHAR_STAT_UUID  = '0000ff02-0000-1000-8000-00805f9b34fb';
        const CHAR_AUDIO_UUID = '0000ff03-0000-1000-8000-00805f9b34fb';
        
        let device, charCmd, charStat, charAudio;
        let isConnected = false;
        
        let originalImage = null, binaryData = null;
        let rawPaths = [], optimizedPaths = [];
        let generatedGcode = ""; 
        let imgWidth = 0, imgHeight = 0;
        
        let allParsedLines = [], lastDrawnIndex = 0;
        
        let audioChunks = [];
        let isRecording = false;
        let audioCtx = null;
        let isFullscreen = false; // [ä¿®å¤ 4] ç¡®ä¿å˜é‡å·²å®šä¹‰
        
        const imgCanvas = document.getElementById('imgCanvas');
        const imgCtx = imgCanvas.getContext('2d');
        const twinCanvas = document.getElementById('twinCanvas');
        const twinCtx = twinCanvas.getContext('2d');

        window.onload = () => {
            resizeTwinCanvas();
            window.addEventListener('resize', resizeTwinCanvas);
        };

        // --- è“ç‰™è¿æ¥é€»è¾‘ (UXä¼˜åŒ–ç‰ˆ) ---
        async function toggleConnection() {
            if (isConnected) await disconnectBLE(); else connectBLE();
        }

        async function connectBLE() {
            if (!navigator.bluetooth) return alert("æµè§ˆå™¨ä¸æ”¯æŒè“ç‰™");
            updateStatus("æ­£åœ¨æœç´¢è®¾å¤‡...", "blue");
            try {
                // è¯·æ±‚è®¾å¤‡
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_UUID] }],
                    optionalServices: [SERVICE_UUID]
                });
                device.addEventListener('gattserverdisconnected', onDisconnected);
                
                // è¿æ¥GATT
                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                
                charCmd = await service.getCharacteristic(CHAR_CMD_UUID);
                charStat = await service.getCharacteristic(CHAR_STAT_UUID);
                charAudio = await service.getCharacteristic(CHAR_AUDIO_UUID);

                await charStat.startNotifications();
                charStat.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                
                await charAudio.startNotifications();
                charAudio.addEventListener('characteristicvaluechanged', handleAudioData);

                onConnected();
            } catch (e) {
                // å¦‚æœæ˜¯ç”¨æˆ·å–æ¶ˆï¼Œæ¢å¤UIçŠ¶æ€
                if(e.message.includes("cancelled")) {
                    updateStatus("ç”¨æˆ·å·²å–æ¶ˆ", "black");
                } else {
                    updateStatus("è¿æ¥å¤±è´¥: " + e.message, "red");
                    console.error(e);
                }
            }
        }

        // [ä¿®å¤ 2] å¢åŠ  device.forget()ï¼Œå½»åº•æ¸…é™¤æµè§ˆå™¨å¯¹è®¾å¤‡çš„æˆæƒç¼“å­˜
        // è¿™æ ·ä¸‹æ¬¡ç‚¹å‡»è¿æ¥æ—¶ï¼Œä¸ä¼šç›´æ¥æ˜¾ç¤º"å·²é…å¯¹"ï¼Œè€Œæ˜¯é‡æ–°æœç´¢
        async function disconnectBLE() {
            if (device) {
                if(device.gatt.connected) await device.gatt.disconnect();
                
                try {
                    // è¿™æ˜¯ Chrome å®éªŒæ€§åŠŸèƒ½ï¼Œå¤§éƒ¨åˆ†ç°ä»£ Chrome/Edge éƒ½æ”¯æŒ
                    if(device.forget) await device.forget();
                } catch(e) {
                    console.log("Browser doesn't support forget()", e);
                }
            }
        }

        function onConnected() {
            isConnected = true;
            document.getElementById('btText').innerText = "å·²è¿æ¥";
            document.getElementById('btIcon').innerText = "âœ…";
            const btn = document.getElementById('connectBtn');
            btn.style.borderColor = "var(--success)";
            btn.style.color = "var(--success)";
            updateStatus("è®¾å¤‡å·²å°±ç»ª", "green");
            toggleTurbo();
            if (generatedGcode) document.getElementById('uploadBtn').disabled = false;
        }

        function onDisconnected() {
            isConnected = false;
            document.getElementById('btText').innerText = "è¿æ¥è®¾å¤‡";
            document.getElementById('btIcon').innerText = "ğŸ“¡";
            const btn = document.getElementById('connectBtn');
            btn.style.borderColor = "#E5E5EA";
            btn.style.color = "var(--primary)";
            setBreathing(false);
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('controlBtn').classList.add('hidden');
            document.getElementById('uploadBtn').classList.remove('hidden');
            updateStatus("è®¾å¤‡å·²æ–­å¼€", "red");
        }

        // --- å½•éŸ³ä¸éŸ³é¢‘å¤„ç† ---
        function handleAudioData(e) {
            if (!isRecording) return;
            const data = new Uint8Array(e.target.value.buffer);
            for(let i=0; i<data.length; i++) {
                audioChunks.push(data[i]);
            }
            document.getElementById('audioStats').innerText = `å·²æ¥æ”¶: ${(audioChunks.length/1024).toFixed(1)} KB`;
        }

        function startLocalRecording() {
            isRecording = true;
            audioChunks = [];
            document.getElementById('recIndicator').classList.add('recording-active');
            updateStatus("ğŸ™ï¸ æ­£åœ¨å½•éŸ³...", "red");
            document.getElementById('playRecBtn').disabled = true;
        }

        function stopLocalRecording() {
            isRecording = false;
            document.getElementById('recIndicator').classList.remove('recording-active');
            updateStatus("å½•éŸ³å®Œæˆ", "green");
            document.getElementById('playRecBtn').disabled = false;
            document.getElementById('audioStats').innerText = `å°±ç»ª: ${(audioChunks.length/1024).toFixed(1)} KB`;
        }

        function playLastRecording() {
            if (audioChunks.length === 0) return;
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            const sampleRate = 8000;
            const buffer = audioCtx.createBuffer(1, audioChunks.length, sampleRate);
            const channelData = buffer.getChannelData(0);

            for (let i = 0; i < audioChunks.length; i++) {
                channelData[i] = (audioChunks[i] - 128) / 128.0;
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(audioCtx.destination);
            source.start();
            updateStatus("â–¶ï¸ æ­£åœ¨æ’­æ”¾...", "blue");
            source.onended = () => updateStatus("æ’­æ”¾ç»“æŸ", "black");
        }

        // --- çŠ¶æ€å¤„ç† ---
        function handleStatusUpdate(e) {
            const val = e.target.value;
            const dec = new TextDecoder();
            const str = dec.decode(val);
            try {
                const d = JSON.parse(str);
                
                if (d.rec !== undefined) {
                    if (d.rec === 1) startLocalRecording();
                    else stopLocalRecording();
                    return; 
                }

                const btn = document.getElementById('controlBtn');
                if(d.s === 1) { // Running
                    if(!btn.innerText.includes("æš‚åœ")) {
                        btn.innerText = "â¸ æš‚åœ"; btn.className = "btn btn-danger col-span-2";
                        btn.disabled = false; btn.classList.remove('hidden');
                        document.getElementById('uploadBtn').classList.add('hidden');
                        setBreathing(true);
                    }
                    const total = allParsedLines.length;
                    const pct = total>0 ? Math.round((d.i/total)*100) : 0;
                    document.getElementById('progressFill').style.width = pct+"%";
                    updateStatus(`ç»˜ç”»ä¸­: ${pct}%`, "green");
                } else if(d.s === 2) { // Paused
                    if(!btn.innerText.includes("ç»§ç»­")) {
                        btn.innerText = "â–¶ ç»§ç»­"; btn.className = "btn btn-success col-span-2";
                        setBreathing(false);
                    }
                } else if(d.s === 3) { // Finished
                    updateStatus("å®Œæˆ! ğŸ‰", "green");
                    btn.innerText = "â–¶ å†æ¬¡ç»˜ç”»"; btn.className = "btn btn-success col-span-2";
                    setBreathing(false);
                }
                if(d.i > lastDrawnIndex) {
                    drawSegment(lastDrawnIndex, d.i);
                    lastDrawnIndex = d.i;
                }
            } catch(err){}
        }

        async function sendCommand(cmd) {
            if(!charCmd) return;
            const enc = new TextEncoder();
            await charCmd.writeValue(enc.encode(cmd));
        }

        // [æ–°å¢] å‘é€æµ‹è¯•éŸ³æ•ˆæŒ‡ä»¤
        function sendTestAudio() {
            const id = document.getElementById('testTrackInput').value;
            if(id) sendCommand('CMD:TEST_AUDIO:' + id);
        }

        async function toggleTurbo() {
            if(!isConnected) return;
            const on = document.getElementById('turboToggle').checked;
            await sendCommand(on ? "CMD:TURBO_ON" : "CMD:TURBO_OFF");
        }

        function updateStatus(msg, color) {
            const el = document.getElementById('status');
            el.innerText = msg;
            if(color==='red') el.style.color = 'var(--danger)';
            else if(color==='green') el.style.color = 'var(--success)';
            else el.style.color = 'var(--text-main)';
        }

        function setBreathing(enable) {
            const st = document.getElementById('status');
            if(enable) st.classList.add('status-breathing');
            else st.classList.remove('status-breathing');
        }

        function toggleDebug() {
            const p = document.getElementById('debugPanel');
            p.classList.toggle('hidden');
        }

        // --- å›¾åƒå¤„ç†ä¸GCodeç”Ÿæˆ (å®Œæ•´ä¿ç•™) ---
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt) {
                const img = new Image();
                img.onload = function() {
                    resetUIForNewImage();
                    const maxSize = 800;
                    let w = img.width, h = img.height;
                    if (w > maxSize || h > maxSize) {
                        const ratio = Math.min(maxSize / w, maxSize / h);
                        w = Math.round(w * ratio); h = Math.round(h * ratio);
                    }
                    imgWidth = w; imgHeight = h;
                    const aspectRatio = (h / w) * 100 + "%";
                    document.getElementById('imgContainer').style.paddingTop = aspectRatio;
                    document.getElementById('twinContainer').style.paddingTop = aspectRatio;
                    imgCanvas.width = w; imgCanvas.height = h;
                    imgCtx.drawImage(img, 0, 0, w, h);
                    originalImage = imgCtx.getImageData(0, 0, w, h);
                    document.getElementById('imgPlaceholder').style.display = 'none';
                    const pBtn = document.getElementById('processBtn');
                    pBtn.disabled = false;
                    pBtn.classList.remove('btn-success');
                    pBtn.classList.add('btn-primary');
                    document.getElementById('processBtnText').innerText = "âœ¨ è½¬æ¢å›¾ç‰‡ä¸ºè·¯å¾„";
                    document.getElementById('pathStats').innerText = `å›¾ç‰‡: ${w}x${h}px`;
                    generatedGcode = ""; rawPaths = []; 
                    document.getElementById('uploadBtn').disabled = true;
                    updateBinaryPreview();
                    setTimeout(resizeTwinCanvas, 100);
                }
                img.src = evt.target.result;
            }
            reader.readAsDataURL(file);
        });

        function resetUIForNewImage() {
            document.getElementById('controlBtn').classList.add('hidden'); 
            document.getElementById('uploadBtn').classList.remove('hidden'); 
            document.getElementById('uploadBtn').disabled = true; 
            document.getElementById('uploadBtn').innerText = "ğŸ“¡ å‘é€ä»»åŠ¡"; 
            document.getElementById('progressFill').style.width = "0%"; 
            setBreathing(false); 
            updateStatus("å›¾ç‰‡å·²åŠ è½½", "black");
        }

        document.getElementById('threshold').addEventListener('input', (e) => {
            document.getElementById('thresholdVal').innerText = e.target.value;
            if(originalImage) updateBinaryPreview();
        });
        document.getElementById('smoothing').addEventListener('input', (e) => {
            document.getElementById('smoothingVal').innerText = e.target.value;
            if(rawPaths && rawPaths.length > 0) updatePathsAndGcode();
        });

        function updateBinaryPreview() {
            if(!originalImage) return;
            const th = parseInt(document.getElementById('threshold').value);
            const output = imgCtx.createImageData(imgWidth, imgHeight);
            const d = originalImage.data; const out = output.data;
            for(let i=0; i<d.length; i+=4) {
                const gray = 0.34*d[i] + 0.5*d[i+1] + 0.16*d[i+2];
                const val = gray < th ? 0 : 255;
                out[i]=out[i+1]=out[i+2]=val; out[i+3]=255;
            }
            imgCtx.putImageData(output, 0, 0);
        }

        async function processImage() {
            if(!originalImage) return;
            const btn = document.getElementById('processBtn');
            const loader = document.getElementById('loader');
            const txt = document.getElementById('processBtnText');
            btn.disabled = true; loader.classList.remove('hidden'); txt.innerText = "æ­£åœ¨è¿ç®—...";
            setTimeout(() => {
                try {
                    const th = parseInt(document.getElementById('threshold').value);
                    const hollow = document.getElementById('hollowSolids').checked;
                    prepareBinaryData(th);
                    if(hollow) hollowSolids();
                    skeletonize();
                    tracePaths();
                    updatePathsAndGcode();
                    btn.classList.remove('btn-primary'); btn.classList.add('btn-success');
                    updateStatus("è½¬æ¢æˆåŠŸï¼Œå‡†å¤‡å‘é€", "green");
                } catch(e) { console.error(e); updateStatus("ç®—æ³•é”™è¯¯", "red"); } finally {
                    btn.disabled = false; loader.classList.add('hidden'); txt.innerText = "âœ¨ è½¬æ¢å®Œæˆ";
                }
            }, 50);
        }

        function updatePathsAndGcode() {
            const sm = parseFloat(document.getElementById('smoothing').value);
            const sorted = sortAndMergePaths(rawPaths);
            optimizedPaths = sorted.map(p => simplifyPathRDP(p, sm));
            generateGcodeInternal();
            const pts = optimizedPaths.reduce((a,p)=>a+p.length,0);
            document.getElementById('pathStats').innerText = `è·¯å¾„: ${optimizedPaths.length} | èŠ‚ç‚¹: ${pts}`;
            resizeTwinCanvas();
            if(isConnected) document.getElementById('uploadBtn').disabled = false;
        }

        function prepareBinaryData(th) {
            binaryData = new Int8Array(imgWidth*imgHeight);
            const d = originalImage.data;
            for(let i=0; i<imgWidth*imgHeight; i++) {
                const val = (0.34*d[i*4]+0.5*d[i*4+1]+0.16*d[i*4+2]);
                binaryData[i] = val < th ? 1 : 0;
            }
        }
        function getPixel(x,y){ if(x<0||x>=imgWidth||y<0||y>=imgHeight)return 0; return binaryData[y*imgWidth+x]; }
        function hollowSolids() {
            const t = new Int8Array(binaryData);
            for(let y=1; y<imgHeight-1; y++) {
                for(let x=1; x<imgWidth-1; x++) {
                    const idx = y*imgWidth+x;
                    if(t[idx] && t[idx-1] && t[idx+1] && t[idx-imgWidth] && t[idx+imgWidth]) binaryData[idx]=0;
                }
            }
        }
        function skeletonize() {
            let changed=true; const rem=[];
            while(changed) {
                changed=false;
                for(let pass=0; pass<2; pass++) {
                    rem.length=0;
                    for(let y=1; y<imgHeight-1; y++){
                        for(let x=1; x<imgWidth-1; x++){
                            if(getPixel(x,y)){
                                const p2=getPixel(x,y-1), p3=getPixel(x+1,y-1), p4=getPixel(x+1,y);
                                const p5=getPixel(x+1,y+1), p6=getPixel(x,y+1), p7=getPixel(x-1,y+1);
                                const p8=getPixel(x-1,y), p9=getPixel(x-1,y-1);
                                const A = (p2==0&&p3==1)+(p3==0&&p4==1)+(p4==0&&p5==1)+(p5==0&&p6==1)+(p6==0&&p7==1)+(p7==0&&p8==1)+(p8==0&&p9==1)+(p9==0&&p2==1);
                                const B = p2+p3+p4+p5+p6+p7+p8+p9;
                                const m1 = pass==0 ? (p2*p4*p6) : (p2*p4*p8);
                                const m2 = pass==0 ? (p4*p6*p8) : (p2*p6*p8);
                                if(A==1 && B>=2 && B<=6 && m1==0 && m2==0) rem.push(y*imgWidth+x);
                            }
                        }
                    }
                    if(rem.length>0){ changed=true; for(let i=0; i<rem.length; i++) binaryData[rem[i]]=0; }
                }
            }
        }
        function tracePaths() {
            rawPaths=[]; const visited=new Int8Array(imgWidth*imgHeight);
            for(let y=0; y<imgHeight; y++){
                for(let x=0; x<imgWidth; x++){
                    const idx=y*imgWidth+x;
                    if(binaryData[idx] && !visited[idx]) {
                        let path=[]; let cx=x, cy=y;
                        while(true) {
                            path.push({x:cx,y:cy}); visited[cy*imgWidth+cx]=1; let found=false;
                            const ns=[{dx:1,dy:0},{dx:1,dy:1},{dx:0,dy:1},{dx:-1,dy:1},{dx:-1,dy:0},{dx:-1,dy:-1},{dx:0,dy:-1},{dx:1,dy:-1}];
                            for(let n of ns) {
                                const nx=cx+n.dx, ny=cy+n.dy;
                                if(nx>=0&&nx<imgWidth&&ny>=0&&ny<imgHeight) {
                                    if(binaryData[ny*imgWidth+nx] && !visited[ny*imgWidth+nx]) { cx=nx; cy=ny; found=true; break; }
                                }
                            }
                            if(!found) break;
                        }
                        if(path.length>2) rawPaths.push(path);
                    }
                }
            }
        }
        function sortAndMergePaths(paths) {
            if(paths.length===0) return [];
            let rem = paths.map(p=>[...p]), sorted = [], curr = rem.shift();
            while(true) {
                let best=-1, minD=Infinity, rev=false, tip=curr[curr.length-1];
                for(let i=0; i<rem.length; i++) {
                    const start=rem[i][0], end=rem[i][rem[i].length-1];
                    const d1=(tip.x-start.x)**2+(tip.y-start.y)**2;
                    const d2=(tip.x-end.x)**2+(tip.y-end.y)**2;
                    if(d1<minD){minD=d1; best=i; rev=false;}
                    if(d2<minD){minD=d2; best=i; rev=true;}
                }
                if(best===-1) { sorted.push(curr); if(rem.length>0) { curr=rem.shift(); continue; } else break; }
                if(minD<=5) { const next=rem[best]; if(rev) next.reverse(); curr.push(...next); rem.splice(best,1); } 
                else { sorted.push(curr); const next=rem[best]; if(rev) next.reverse(); curr=next; rem.splice(best,1); }
            }
            return sorted;
        }
        function simplifyPathRDP(path, epsilon) {
            if (path.length < 3) return path; 
            let dmax = 0, index = 0; const end = path.length - 1;
            const lineStart = path[0], lineEnd = path[end];
            for (let i = 1; i < end; i++) {
                const p = path[i];
                let d = 0;
                const dx = lineEnd.x - lineStart.x, dy = lineEnd.y - lineStart.y;
                const lenSq = dx * dx + dy * dy;
                if (lenSq === 0) d = Math.sqrt((p.x - lineStart.x)**2 + (p.y - lineStart.y)**2);
                else {
                    let t = ((p.x - lineStart.x) * dx + (p.y - lineStart.y) * dy) / lenSq;
                    if (t < 0) t = 0; else if (t > 1) t = 1;
                    d = Math.sqrt((p.x - (lineStart.x + t * dx))**2 + (p.y - (lineStart.y + t * dy))**2);
                }
                if (d > dmax) { index = i; dmax = d; }
            }
            if (dmax > epsilon) {
                const r1 = simplifyPathRDP(path.slice(0, index + 1), epsilon);
                const r2 = simplifyPathRDP(path.slice(index, path.length), epsilon);
                return r1.slice(0, r1.length - 1).concat(r2);
            } else return [path[0], path[end]];
        }
        function generateGcodeInternal() {
            const WORK_WIDTH = 100.0; const scale = WORK_WIDTH / Math.max(imgWidth, 1);
            let g = "G90\nM5\n";
            optimizedPaths.forEach(p => {
                if(p.length===0) return;
                g+=`G0 X${(p[0].x*scale).toFixed(2)} Y${((imgHeight-p[0].y)*scale).toFixed(2)}\nM3 S1000\n`;
                for(let i=1; i<p.length; i++) g+=`G1 X${(p[i].x*scale).toFixed(2)} Y${((imgHeight-p[i].y)*scale).toFixed(2)}\n`;
                g+=`M5\n`;
            });
            g+="G0 X0 Y0\n"; generatedGcode = g; parseAllLines(g); drawTwinPreview(g, '#e0e0e0');
        }

        // --- ä¼ è¾“é€»è¾‘ ---
        async function startUploadAndPrint() {
            if(!generatedGcode || !charCmd) return;
            const btn = document.getElementById('uploadBtn');
            btn.disabled = true; btn.innerText = "â³ ä¼ è¾“ä¸­...";
            lastDrawnIndex = 0; setBreathing(true);
            try {
                updateStatus("æ­£åœ¨åˆå§‹åŒ–...", "blue"); await sendCommand("CMD:NEWFILE");
                const lines = generatedGcode.split('\n'); let chunk = ""; const CHUNK=150; 
                for(let i=0; i<lines.length; i++) {
                    let line = lines[i].trim(); if(!line) continue; line += "\n";
                    if(chunk.length + line.length > CHUNK) {
                        await sendCommand(chunk); chunk = "";
                        if(i%5===0) { 
                            const pct = Math.round((i/lines.length)*100);
                            document.getElementById('progressFill').style.width = pct+"%";
                            updateStatus(`ä¸Šä¼ ä¸­: ${pct}%`, "blue");
                            await new Promise(r=>setTimeout(r, 5));
                        }
                    }
                    chunk += line;
                }
                if(chunk) await sendCommand(chunk);
                document.getElementById('progressFill').style.width = "100%";
                updateStatus("ä¸Šä¼ å®Œæˆï¼Œè¯·å¼€å§‹", "green");
                btn.classList.add('hidden'); document.getElementById('controlBtn').classList.remove('hidden');
            } catch(e) {
                updateStatus("ä¸Šä¼ å¤±è´¥", "red"); setBreathing(false); btn.disabled = false; btn.innerText = "ğŸ“¡ é‡è¯•";
            }
        }

        async function toggleDrawing() {
            const btn = document.getElementById('controlBtn');
            if(btn.innerText.includes("å¼€å§‹") || btn.innerText.includes("ç»§ç»­") || btn.innerText.includes("å†æ¬¡")) {
                await sendCommand("CMD:START");
                btn.innerText = "â¸ æš‚åœ"; btn.className = "btn btn-danger col-span-2";
                updateStatus("ç»˜ç”»ä¸­...", "green"); setBreathing(true); 
            } else {
                await sendCommand("CMD:STOP");
                btn.innerText = "â–¶ ç»§ç»­"; btn.className = "btn btn-success col-span-2";
                updateStatus("å·²æš‚åœ", "orange"); setBreathing(false); 
            }
        }

        // --- å­ªç”Ÿç»˜å›¾ ---
        function parseAllLines(text) {
            allParsedLines = []; let cx=0, cy=0, down=false;
            const container = document.getElementById('twinContainer');
            const cw = container.clientWidth || 300; const ch = container.clientHeight || 300;
            const scale = (cw*0.9)/100.0, ox = cw*0.05, oy = ch*0.05;
            text.split('\n').forEach(l => {
                if(l.includes('M3')) down=true; if(l.includes('M5')) down=false;
                const zm = l.match(/Z([-\d.]+)/); if(zm) down=(parseFloat(zm[1])<=0);
                const xm = l.match(/X([-\d.]+)/), ym = l.match(/Y([-\d.]+)/);
                const gx = xm?parseFloat(xm[1]):cx; const gy = ym?parseFloat(ym[1]):cy;
                const tx = gx*scale + ox; const ty = ch - (gy*scale) - oy;
                allParsedLines.push({x:tx, y:ty, down:down, valid:(l.includes('G0')||l.includes('G1'))});
                if(xm) cx=gx; if(ym) cy=gy;
            });
        }
        function drawTwinPreview(txt, col) {
            twinCtx.clearRect(0,0,twinCanvas.width,twinCanvas.height);
            twinCtx.lineCap='round'; twinCtx.lineJoin='round';
            twinCtx.beginPath(); twinCtx.strokeStyle=col; twinCtx.lineWidth=1;
            if(allParsedLines.length===0) return;
            twinCtx.moveTo(allParsedLines[0].x, allParsedLines[0].y);
            for(let i=1; i<allParsedLines.length; i++) {
                const p = allParsedLines[i];
                if(p.valid) { if(p.down) twinCtx.lineTo(p.x, p.y); else twinCtx.moveTo(p.x, p.y); }
            }
            twinCtx.stroke();
        }
        function drawSegment(start, end) {
            if(end>=allParsedLines.length) end=allParsedLines.length-1;
            twinCtx.beginPath(); twinCtx.strokeStyle='#007AFF'; twinCtx.lineWidth=2;
            let sp = allParsedLines[start]; if(!sp) return;
            twinCtx.moveTo(sp.x, sp.y);
            for(let i=start+1; i<=end; i++) {
                const p = allParsedLines[i];
                if(p.valid) { if(p.down) twinCtx.lineTo(p.x, p.y); else twinCtx.moveTo(p.x, p.y); }
            }
            twinCtx.stroke();
        }
        function resizeTwinCanvas() {
            const container = isFullscreen ? fullscreenModal : document.getElementById('imgContainer');
            const rect = document.getElementById('twinContainer').getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            twinCanvas.width = rect.width * dpr; twinCanvas.height = rect.height * dpr;
            twinCtx.scale(dpr, dpr);
            if(generatedGcode) drawTwinPreview(generatedGcode, '#e0e0e0');
        }
        function toggleFullscreen(show) {
            isFullscreen = show; const c = document.getElementById('imgContainer');
            if (show) { fullscreenModal.classList.remove('hidden'); fullscreenModal.appendChild(imgCanvas); } 
            else { fullscreenModal.classList.add('hidden'); c.appendChild(imgCanvas); }
        }
    </script>
</body>
</html>