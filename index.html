<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <title>Robot Twin BLE 3.0</title>
    <style>
        :root { --primary: #007AFF; --bg: #f4f7f9; --card-bg: #ffffff; }
        body { text-align: center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--bg); padding: 10px; margin: 0; color: #333; }
        
        /* å¡ç‰‡å®¹å™¨ */
        .card { 
            background: var(--card-bg); border-radius: 20px; padding: 20px; margin: 10px auto; 
            max-width: 420px; box-shadow: 0 8px 20px rgba(0,0,0,0.08); 
        }

        /* æ ‡é¢˜æ  */
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        h2 { margin: 0; font-size: 1.2rem; }
        .badge { font-size: 0.8rem; padding: 4px 8px; border-radius: 12px; background: #eee; color: #666; }
        .badge.connected { background: #34C759; color: white; }

        /* ç”»å¸ƒåŒºåŸŸ */
        .canvas-container { position: relative; width: 100%; padding-top: 100%; /* 1:1 Aspect Ratio */ background: #f9f9f9; border-radius: 15px; border: 1px solid #eee; margin-bottom: 15px; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* æŒ‰é’®æ ·å¼ */
        .btn { 
            background: var(--primary); color: white; border: none; padding: 14px; 
            border-radius: 12px; width: 100%; font-size: 1rem; font-weight: 600;
            cursor: pointer; margin-top: 10px; transition: opacity 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .btn:active { opacity: 0.8; }
        .btn:disabled { background: #e0e0e0; color: #999; cursor: not-allowed; }
        .btn-stop { background: #FF3B30; }
        .btn-outline { background: transparent; border: 2px solid var(--primary); color: var(--primary); }
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }

        /* çŠ¶æ€æ˜¾ç¤º */
        #status { margin-top: 15px; font-size: 0.9rem; color: #666; min-height: 20px; word-break: break-all;}
        
        /* è¿›åº¦æ¡ */
        .progress-bar { height: 6px; background: #eee; border-radius: 3px; margin: 15px 0; overflow: hidden; display: none; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.3s; }
        
        /* è°ƒè¯•æ§åˆ¶ */
        .debug-panel { margin-top: 20px; padding-top: 15px; border-top: 1px dashed #eee; display: none; }
    </style>
</head>
<body>

    <div class="card">
        <div class="header">
            <h2>ğŸ¨ ESP32 Robot Twin</h2>
            <span id="connectionBadge" class="badge">æœªè¿æ¥</span>
        </div>

        <div class="canvas-container">
            <canvas id="preview"></canvas>
        </div>

        <div id="progressContainer" class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
        </div>

        <div id="status">å‡†å¤‡å°±ç»ªï¼Œè¯·è¿æ¥è®¾å¤‡</div>

        <button id="connectBtn" class="btn" onclick="toggleConnection()">ğŸ“¡ è¿æ¥è“ç‰™è®¾å¤‡</button>
        
        <input type="file" id="fileInput" accept=".gcode,.txt,.nc" style="display:none" onchange="handleFileSelect(this.files[0])">
        <button id="loadBtn" class="btn btn-outline" onclick="document.getElementById('fileInput').click()" disabled>ğŸ“‚ 1. åŠ è½½ G-Code</button>
        <button id="uploadBtn" class="btn" onclick="startUploadAndPrint()" disabled>â–¶ï¸ 2. ä¸Šä¼ å¹¶å¼€å§‹æ‰“å°</button>

        <div class="btn-group">
            <button id="stopBtn" class="btn btn-stop" onclick="sendCommand('CMD:STOP')" disabled>â¸ æš‚åœ</button>
            <button class="btn btn-outline" onclick="toggleDebug()">ğŸ›  è°ƒè¯•</button>
        </div>

        <div id="debugPanel" class="debug-panel">
            <div class="btn-group">
                <button class="btn btn-outline" onclick="sendCommand('CMD:SERVO_FWD')">â¬‡ è½ç¬”</button>
                <button class="btn btn-outline" onclick="sendCommand('CMD:SERVO_REV')">â¬† æŠ¬ç¬”</button>
            </div>
            <div style="margin-top:10px; font-size:0.8rem; color:#999;">UUID: ...34fb</div>
        </div>
    </div>

    <script>
        // --- é…ç½®å¸¸é‡ ---
        const SERVICE_UUID = '000000ff-0000-1000-8000-00805f9b34fb';
        const CHAR_CMD_UUID = '000000ff-0000-1000-8000-00805f9b3401';
        const CHAR_STAT_UUID = '000000ff-0000-1000-8000-00805f9b3402';
        
        // --- å…¨å±€å˜é‡ ---
        let device, server, service, charCmd, charStat;
        let gcodeContent = "";
        let autoScale = 1.0;
        let canvas, ctx;
        let width, height;
        let isConnected = false;
        
        // æ•°å­—å­ªç”ŸçŠ¶æ€
        let twinX = 0, twinY = 0;

        // PWA Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js').catch(console.error);
        }

        window.onload = () => {
            canvas = document.getElementById('preview');
            ctx = canvas.getContext('2d');
            // é€‚é…é«˜æ¸…å±
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            width = rect.width;
            height = rect.height;
            resetCanvas();
        };

        // --- è“ç‰™è¿æ¥é€»è¾‘ ---
        async function toggleConnection() {
            if (isConnected) {
                disconnectBLE();
            } else {
                connectBLE();
            }
        }

        async function connectBLE() {
            updateStatus("æ­£åœ¨æœç´¢è®¾å¤‡...", "blue");
            try {
                // [å…³é”®ä¿®å¤] ä½¿ç”¨ services è¿‡æ»¤ï¼Œè§£å†³æ‰«æå“åº”åŒ…åå­—ä¸¢å¤±å¯¼è‡´çš„ä¸å¯è§é—®é¢˜
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_UUID] }],
                    optionalServices: [SERVICE_UUID]
                });

                device.addEventListener('gattserverdisconnected', onDisconnected);
                updateStatus("æ­£åœ¨è¿æ¥ GATT...", "blue");
                
                server = await device.gatt.connect();
                service = await server.getPrimaryService(SERVICE_UUID);
                charCmd = await service.getCharacteristic(CHAR_CMD_UUID);
                charStat = await service.getCharacteristic(CHAR_STAT_UUID);

                // å¼€å¯é€šçŸ¥
                await charStat.startNotifications();
                charStat.addEventListener('characteristicvaluechanged', handleStatusUpdate);

                onConnected();
            } catch (error) {
                console.error(error);
                updateStatus("è¿æ¥å¤±è´¥: " + error.message, "red");
            }
        }

        function disconnectBLE() {
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
        }

        function onConnected() {
            isConnected = true;
            document.getElementById('connectionBadge').innerText = "å·²è¿æ¥";
            document.getElementById('connectionBadge').classList.add("connected");
            document.getElementById('connectBtn').innerText = "âŒ æ–­å¼€è¿æ¥";
            document.getElementById('connectBtn').classList.add("btn-outline");
            document.getElementById('loadBtn').disabled = false;
            if (gcodeContent) document.getElementById('uploadBtn').disabled = false;
            updateStatus("è®¾å¤‡å·²å°±ç»ª", "green");
            
            // æ¯æ¬¡è¿æ¥é‡ç½®æ•°å­—å­ªç”Ÿä½ç½®
            twinX = 0; twinY = 0;
        }

        function onDisconnected() {
            isConnected = false;
            document.getElementById('connectionBadge').innerText = "æœªè¿æ¥";
            document.getElementById('connectionBadge').classList.remove("connected");
            document.getElementById('connectBtn').innerText = "ğŸ“¡ è¿æ¥è“ç‰™è®¾å¤‡";
            document.getElementById('connectBtn').classList.remove("btn-outline");
            document.getElementById('loadBtn').disabled = true;
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            updateStatus("è®¾å¤‡å·²æ–­å¼€", "orange");
        }

        // --- G-Code å¤„ç†ä¸ä¸Šä¼  ---
        async function handleFileSelect(file) {
            if (!file) return;
            const text = await file.text();
            gcodeContent = text;
            
            // 1. è®¡ç®—ç¼©æ”¾å¹¶ç»˜åˆ¶é¢„è§ˆ (ç°è‰²èƒŒæ™¯è½¨è¿¹)
            calculateScale(text);
            resetCanvas();
            drawPreview(text, '#e0e0e0'); // é¢„è§ˆè‰²
            
            document.getElementById('uploadBtn').disabled = !isConnected;
            updateStatus(`å·²åŠ è½½: ${file.name} (${(file.size/1024).toFixed(1)}KB)`, "black");
        }

        async function startUploadAndPrint() {
            if (!gcodeContent) return;
            if (!charCmd) return;

            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('progressContainer').style.display = 'block';
            
            try {
                // 1. å‘é€æ–°æ–‡ä»¶æŒ‡ä»¤
                updateStatus("æ­£åœ¨é‡ç½®æ–‡ä»¶...", "blue");
                await sendCommand("CMD:NEWFILE");

                // 2. åˆ†ç‰‡å‘é€
                const lines = gcodeContent.split('\n');
                const total = lines.length;
                let buffer = "";
                const CHUNK_SIZE = 400; // èšåˆå¤šä¸ªçŸ­è¡Œï¼Œå‡å°‘BLEåŒ…å¤´å¼€é”€

                for (let i = 0; i < total; i++) {
                    const line = lines[i].trim();
                    if (line.length === 0 || line.startsWith(';')) continue;
                    
                    // ç®€å•æµæ§
                    await sendCommand(line + "\n");
                    
                    // æ›´æ–°UI
                    if (i % 20 === 0) {
                        const pct = Math.round((i / total) * 100);
                        document.getElementById('progressFill').style.width = pct + "%";
                        updateStatus(`ä¸Šä¼ ä¸­... ${pct}%`, "blue");
                        await new Promise(r => setTimeout(r, 10)); // ç»™UIå–˜æ¯æ—¶é—´
                    }
                }
                
                updateStatus("ä¸Šä¼ å®Œæˆï¼Œå‘é€å¯åŠ¨æŒ‡ä»¤...", "blue");
                await sendCommand("CMD:START");
                
            } catch (e) {
                updateStatus("ä¸Šä¼ ä¸­æ–­: " + e.message, "red");
                document.getElementById('uploadBtn').disabled = false;
            }
        }

        async function sendCommand(cmd) {
            if (!charCmd) return;
            const encoder = new TextEncoder();
            // å†™å…¥å¹¶ä¸ç­‰å¾…å“åº”ï¼Œæé«˜é€Ÿåº¦ (Write Without Response)
            // æ³¨æ„ï¼šå¦‚æœ ESP32 ç«¯å¤„ç†ä¸è¿‡æ¥ï¼Œå¯èƒ½éœ€è¦åŠ çŸ­æš‚å»¶æ—¶
            await charCmd.writeValue(encoder.encode(cmd));
        }

        // --- æ•°å­—å­ªç”Ÿï¼šçŠ¶æ€åé¦ˆä¸å®æ—¶ç»˜å›¾ ---
        function handleStatusUpdate(event) {
            const value = event.target.value;
            const decoder = new TextDecoder();
            const jsonStr = decoder.decode(value);
            
            try {
                // åè®®: {"s":status, "p":progress, "c":"G1 X10 Y20"}
                const data = JSON.parse(jsonStr);
                
                // 1. æ›´æ–°è¿›åº¦æ–‡å­—
                if (data.s === 1) { // Running
                    updateStatus(`æ­£åœ¨ç»˜åˆ¶: ${data.p}%`, "green");
                    document.getElementById('progressFill').style.width = data.p + "%";
                } else if (data.s === 3) { // Finished
                    updateStatus("ç»˜åˆ¶å®Œæˆ! ğŸ‰", "green");
                    document.getElementById('uploadBtn').disabled = false;
                }

                // 2. æ•°å­—å­ªç”Ÿ (æ ¸å¿ƒåŠŸèƒ½)
                // è§£æ ESP32 å½“å‰æ‰§è¡Œçš„æŒ‡ä»¤ï¼Œå¹¶åœ¨ Canvas ä¸Šç»˜åˆ¶å®çº¿
                if (data.c) {
                    drawTwinPath(data.c);
                }

            } catch (e) {
                console.warn("JSON Parse Error:", jsonStr);
            }
        }

        // --- ç»˜å›¾é€»è¾‘ ---
        function resetCanvas() {
            ctx.clearRect(0, 0, width, height);
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
        }

        function calculateScale(text) {
            let maxX = 0, maxY = 0;
            text.split('\n').forEach(line => {
                const x = line.match(/X([\d.]+)/);
                const y = line.match(/Y([\d.]+)/);
                if (x) maxX = Math.max(maxX, parseFloat(x[1]));
                if (y) maxY = Math.max(maxY, parseFloat(y[1]));
            });
            // ç•™ç™½ 20px
            const padding = 20;
            const availW = width - padding * 2;
            const availH = height - padding * 2;
            
            if (maxX > 0 && maxY > 0) {
                const scaleX = availW / maxX;
                const scaleY = availH / maxY;
                autoScale = Math.min(scaleX, scaleY);
            } else {
                autoScale = 1.0;
            }
        }

        // ç»˜åˆ¶é™æ€é¢„è§ˆ (ç°è‰²)
        function drawPreview(text, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            let curX = 0, curY = 0;
            let isDown = false;

            text.split('\n').forEach(line => {
                // è§£æ M3/M5 (å‡è®¾ M3=è½ç¬”, M5=æŠ¬ç¬”)
                if (line.includes('M3')) isDown = true;
                if (line.includes('M5')) isDown = false;
                
                // è§£æåæ ‡
                const xMatch = line.match(/X([\d.]+)/);
                const yMatch = line.match(/Y([\d.]+)/);
                
                if (xMatch) curX = parseFloat(xMatch[1]) * autoScale;
                if (yMatch) curY = parseFloat(yMatch[1]) * autoScale;

                // åæ ‡å˜æ¢ (å¢åŠ è¾¹è· + ç¿»è½¬Yè½´é€‚é… Canvas)
                const drawX = curX + 10;
                const drawY = height - (curY + 10); // å‡è®¾åŸç‚¹åœ¨å·¦ä¸‹è§’

                if (line.includes('G0') || line.includes('G1')) {
                    if (isDown) {
                        ctx.lineTo(drawX, drawY);
                    } else {
                        ctx.moveTo(drawX, drawY);
                    }
                }
            });
            ctx.stroke();
        }

        // ç»˜åˆ¶å®æ—¶å­ªç”Ÿè·¯å¾„ (è“è‰²)
        function drawTwinPath(cmd) {
            // cmd ç±»ä¼¼äº "G1 X10.5 Y20.0"
            if (!cmd.includes('G1') && !cmd.includes('G0')) return;

            const xMatch = cmd.match(/X([\d.]+)/);
            const yMatch = cmd.match(/Y([\d.]+)/);
            
            if (!xMatch && !yMatch) return; // æ²¡æœ‰åæ ‡å˜åŠ¨

            let newX = twinX;
            let newY = twinY;
            
            if (xMatch) newX = parseFloat(xMatch[1]) * autoScale;
            if (yMatch) newY = parseFloat(yMatch[1]) * autoScale;

            const startX = twinX + 10;
            const startY = height - (twinY + 10);
            const endX = newX + 10;
            const endY = height - (newY + 10);

            ctx.beginPath();
            ctx.strokeStyle = '#007AFF'; // å­ªç”Ÿé«˜äº®è‰²
            ctx.lineWidth = 2;
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // æ›´æ–°å½“å‰å­ªç”Ÿåæ ‡
            twinX = newX;
            twinY = newY;
        }

        // --- å·¥å…·å‡½æ•° ---
        function updateStatus(msg, color="black") {
            const el = document.getElementById('status');
            el.innerText = msg;
            el.style.color = color;
        }

        function toggleDebug() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        }
    </script>
</body>
</html>