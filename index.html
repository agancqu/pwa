<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Robot Studio BLE 9.6 (Realtime Trace)</title>
    <style>
        /* --- æ ·å¼éƒ¨åˆ†ä¿æŒä¸å˜ --- */
        :root { --primary: #007AFF; --primary-dark: #0056b3; --success: #34C759; --success-dark: #248a3d; --danger: #FF3B30; --danger-dark: #cc2f26; --bg-color: #F2F2F7; --card-bg: #FFFFFF; --text-main: #1C1C1E; --text-sub: #8E8E93; --border-radius: 16px; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-color); color: var(--text-main); margin: 0; padding-bottom: 20px; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        .max-w-md { max-width: 480px; margin: 0 auto; } .px-4 { padding-left: 1rem; padding-right: 1rem; } .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; } .p-4 { padding: 1rem; } .p-3 { padding: 0.75rem; } .mb-1 { margin-bottom: 0.25rem; } .mb-2 { margin-bottom: 0.5rem; } .mb-3 { margin-bottom: 0.75rem; } .mb-4 { margin-bottom: 1rem; } .mb-12 { margin-bottom: 3rem; } .mt-2 { margin-top: 0.5rem; } .space-y-4 > * + * { margin-top: 1rem; } .relative { position: relative; } .absolute { position: absolute; } .inset-0 { top: 0; right: 0; bottom: 0; left: 0; } .w-full { width: 100%; } .h-full { height: 100%; } .z-10 { z-index: 10; } .opacity-0 { opacity: 0; cursor: pointer; } .flex { display: flex; } .flex-col { flex-direction: column; } .items-center { align-items: center; } .justify-between { justify-content: space-between; } .justify-center { justify-content: center; } .gap-2 { gap: 0.5rem; } .grid { display: grid; } .grid-cols-2 { grid-template-columns: 1fr 1fr; } .col-span-2 { grid-column: span 2; } .text-center { text-align: center; } .text-xs { font-size: 0.75rem; color: var(--text-sub); } .text-sm { font-size: 0.9rem; } .text-lg { font-size: 1.125rem; font-weight: 700; } .font-bold { font-weight: 600; } .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .card { background-color: var(--card-bg); border-radius: var(--border-radius); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); padding: 1.25rem; margin-bottom: 1rem; overflow: hidden; }
        .navbar { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); position: sticky; top: 0; z-index: 50; border-bottom: 1px solid rgba(0,0,0,0.1); }
        #status { font-size: 0.95rem; font-weight: 600; color: var(--text-main); padding: 8px 12px; border-radius: 8px; margin: 8px auto; transition: all 0.5s ease; }
        @keyframes breathe { 0% { background-color: #E0F2FE; } 50% { background-color: #DCFCE7; } 100% { background-color: #E0F2FE; } } .status-breathing { animation: breathe 3s infinite ease-in-out; color: #000 !important; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .btn { width: 100%; padding: 14px 20px; border-radius: 12px; border: none; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 8px; color: white; box-shadow: 0 2px 6px rgba(0,0,0,0.1); } .btn:active { transform: scale(0.97); } .btn:disabled { background-color: #E5E5EA !important; color: #8E8E93 !important; cursor: not-allowed; box-shadow: none; }
        .btn-primary { background-color: var(--primary); } .btn-success { background-color: var(--success); } .btn-danger { background-color: var(--danger); } .btn-outline { background-color: transparent; border: 2px solid #E5E5EA; color: var(--primary); box-shadow: none; padding: 8px 12px; font-size: 0.85rem; width: 100%; }
        .upload-area { background-color: #F2F2F7; border: 2px dashed #C7C7CC; border-radius: 12px; height: 54px; display: flex; align-items: center; justify-content: center; gap: 10px; transition: background-color 0.2s; cursor: pointer; } .upload-area:active { background-color: #E5E5EA; } .upload-icon { font-size: 1.2rem; } .upload-text { font-size: 0.9rem; font-weight: 500; color: var(--text-main); } .upload-sub { font-size: 0.75rem; color: var(--text-sub); }
        .loader { border: 3px solid rgba(255, 255, 255, 0.3); border-top: 3px solid #ffffff; border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; display: inline-block; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } .hidden { display: none !important; }
        canvas { display: block; image-rendering: pixelated; width: 100%; height: 100%; }
        .ratio-container { width: 100%; position: relative; background: #fff; border-radius: 12px; border: 1px solid #E5E5EA; overflow: hidden; box-shadow: inset 0 2px 6px rgba(0,0,0,0.05); padding-top: 100%; }
        .checkerboard-bg { background-image: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #f0f0f0 75%), linear-gradient(-45deg, transparent 75%, #f0f0f0 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
        .fill-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; }
        .fullscreen-modal { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.9); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: zoom-out; } .fullscreen-modal canvas { max-width: 95vw; max-height: 95vh; width: auto !important; height: auto !important; object-fit: contain; }
        .progress-track { background: #E5E5EA; border-radius: 10px; height: 8px; overflow: hidden; margin: 10px 0; } .progress-fill { background: var(--primary); height: 100%; width: 0%; transition: width 0.2s; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #E5E5EA; border-radius: 3px; outline: none; margin: 10px 0; } input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: white; box-shadow: 0 2px 6px rgba(0,0,0,0.2); border-radius: 50%; cursor: pointer; }
        .advanced-summary { padding: 1rem; font-size: 0.95rem; font-weight: 600; background-color: #F9FAFB; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; border-radius: 12px; border: 1px solid #E5E5EA; } .advanced-summary::-webkit-details-marker { display: none; } .summary-arrow { transition: transform 0.3s; color: var(--text-sub); } details[open] .summary-arrow { transform: rotate(180deg); }
        #recIndicator { width: 12px; height: 12px; border-radius: 50%; background-color: #ccc; margin-right: 5px; display: inline-block; } .recording-active { background-color: #FF3B30 !important; animation: blink 1s infinite; } @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div class="navbar px-4 py-3 mb-4">
        <div class="max-w-md flex justify-between items-center mb-2">
            <h1 class="text-lg text-main flex items-center gap-2">ğŸ¤– Robot Studio 9.6</h1>
            <button id="connectBtn" onclick="toggleConnection()" class="btn-outline" style="width: auto; border-radius: 18px;">
                <span id="btIcon">ğŸ“¡</span> <span id="btText">æœªè¿æ¥</span>
            </button>
        </div>
        <div id="status" class="max-w-md text-center truncate">å‡†å¤‡å°±ç»ª (é•¿æŒ‰éŸ³é‡é”®å½•éŸ³)</div>
    </div>

    <div class="max-w-md px-4">

        <div class="card">
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-sm font-bold text-sub uppercase">STEP 1. åˆ¶ä½œ G-Code</h2>
            </div>
            
            <div class="relative upload-area mb-4">
                <input type="file" id="imageInput" accept="image/*" class="absolute inset-0 w-full h-full z-10 opacity-0">
                <span class="upload-icon">ğŸ“¸</span>
                <span class="upload-text">ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</span>
                <span class="upload-sub">(æ”¯æŒæ‹ç…§/ç›¸å†Œ)</span>
            </div>

            <details class="mb-4">
                <summary class="advanced-summary">
                    <span>âš™ï¸ é«˜çº§å‚æ•°è®¾ç½®</span>
                    <span class="summary-arrow">â–¼</span>
                </summary>
                <div class="p-3 pt-4 space-y-4 bg-gray-50 rounded-b-xl border-x border-b border-gray-200">
                    <div class="flex items-center justify-between">
                        <label class="text-sm">ä¿®å¤å®å¿ƒåŒºåŸŸ (ç©ºå¿ƒåŒ–)</label>
                        <input type="checkbox" id="hollowSolids">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>çº¿æ¡é˜ˆå€¼</span><span id="thresholdVal">128</span></div>
                        <input type="range" id="threshold" min="0" max="255" value="128">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>è·¯å¾„å¹³æ»‘</span><span id="smoothingVal">2.0</span></div>
                        <input type="range" id="smoothing" min="0" max="10" step="0.5" value="2.0">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs mb-1"><span>æœ€å°è·¯å¾„è¿‡æ»¤ (mm)</span><span id="minLengthVal">2.0</span></div>
                        <input type="range" id="minLength" min="0" max="5" step="0.1" value="2.0">
                    </div>
                </div>
            </details>

            <div id="imgContainer" class="ratio-container checkerboard-bg mb-4">
                <canvas id="imgCanvas" class="fill-canvas"></canvas>
                <div id="imgPlaceholder" class="absolute inset-0 flex items-center justify-center text-xs text-sub pointer-events-none">å›¾ç‰‡é¢„è§ˆ</div>
            </div>

            <button id="processBtn" onclick="processImage()" class="btn btn-primary" disabled>
                <span id="loader" class="loader hidden"></span>
                <span id="processBtnText">âœ¨ è½¬æ¢å›¾ç‰‡ä¸ºè·¯å¾„</span>
            </button>
            
            <button id="downloadBtn" onclick="downloadGcode()" class="btn btn-outline mt-2" disabled>
                ğŸ’¾ ä¸‹è½½ G-Code æ–‡ä»¶
            </button>

            <div id="pathStats" class="text-center text-xs mt-2" style="min-height: 1rem;"></div>
        </div>

        <div class="card">
            <h2 class="text-sm font-bold text-sub uppercase mb-3">STEP 2. ç»˜ç”»æ§åˆ¶</h2>
            
            <div class="progress-track">
                <div id="progressFill" class="progress-fill"></div>
            </div>

            <div class="grid grid-cols-2 gap-3 mb-4">
                <button id="uploadBtn" onclick="startUploadAndPrint()" class="btn btn-primary col-span-2" disabled>
                    ğŸ“¡ å‘é€ä»»åŠ¡
                </button>
                <button id="controlBtn" onclick="toggleDrawing()" class="btn btn-success col-span-2 hidden">
                    â–¶ å¼€å§‹ç»˜ç”»
                </button>
            </div>

            <div id="twinContainer" class="ratio-container">
                <canvas id="twinCanvas" class="fill-canvas"></canvas>
                <div class="absolute bottom-2 right-2 text-xs text-sub pointer-events-none">Digital Twin</div>
            </div>
        </div>

        <div class="flex justify-center mb-12">
            <button onclick="toggleDebug()" class="text-xs text-sub underline opacity-50 hover:opacity-100 bg-transparent border-none cursor-pointer">
                ğŸ›  æ‰“å¼€è°ƒè¯•é¢æ¿
            </button>
        </div>

        <div id="debugPanel" class="hidden bg-white shadow-sm p-4 rounded-xl border border-gray-200 mb-6 mx-auto max-w-md">
            <div class="flex items-center justify-between mb-3 pb-2 border-b border-gray-200">
                <div class="flex items-center">
                    <span id="recIndicator"></span>
                    <span class="text-xs font-bold text-sub">å½•éŸ³çŠ¶æ€</span>
                </div>
                <div class="text-xs text-gray-500" id="audioStats">æ— æ•°æ®</div>
            </div>

            <div class="flex items-center justify-between mb-3 pb-2 border-b border-gray-200">
                <span class="text-xs font-bold text-sub">è°ƒè¯•æ§åˆ¶</span>
                <label class="flex items-center gap-1 cursor-pointer text-xs text-blue-600">
                    <input type="checkbox" id="turboToggle" onchange="toggleTurbo()">
                    ğŸš€ æé€Ÿä»¿çœŸ
                </label>
            </div>
            
            <div class="grid grid-cols-2 gap-2 mb-2">
                <button class="btn-outline" onclick="sendCommand('CMD:SERVO_FWD')">â¬‡ è½ç¬”</button>
                <button class="btn-outline" onclick="sendCommand('CMD:SERVO_REV')">â¬† æŠ¬ç¬”</button>
            </div>
            
            <div class="grid grid-cols-2 gap-2">
                <button class="btn-outline" onclick="sendCommand('CMD:HOME')">ğŸ  å½’ä½æ ¡å‡†</button>
                <div style="display: flex; gap: 5px;">
                    <input type="number" id="testTrackInput" value="1" min="1" max="255" style="width: 40px; text-align: center; border: 1px solid #E5E5EA; border-radius: 8px; background: transparent; color: var(--primary); outline: none;">
                    <button class="btn-outline" style="flex: 1;" onclick="sendTestAudio()">ğŸ”Š æµ‹è¯•</button>
                </div>
            </div>

            <button id="playRecBtn" onclick="playLastRecording()" class="btn btn-primary mt-3" disabled>
                â–¶ï¸ æ’­æ”¾æœ€è¿‘å½•éŸ³
            </button>

            <div class="mt-2 text-xs text-gray-400 text-center break-all">
                UUID: ...ee...34fb
            </div>
        </div>

        <div class="text-center text-xs text-sub pb-2">Robot Studio BLE 9.6 (Realtime Trace)</div>
    </div>

    <div id="fullscreenModal" class="fullscreen-modal hidden" onclick="toggleFullscreen(false)">
    </div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const SERVICE_UUID    = '000000ee-0000-1000-8000-00805f9b34fb';
        const CHAR_CMD_UUID   = '0000ff01-0000-1000-8000-00805f9b34fb';
        const CHAR_STAT_UUID  = '0000ff02-0000-1000-8000-00805f9b34fb';
        const CHAR_AUDIO_UUID = '0000ff03-0000-1000-8000-00805f9b34fb';
        
        let device, charCmd, charStat, charAudio;
        let isConnected = false;
        
        let originalImage = null, binaryData = null;
        let rawPaths = [], optimizedPaths = [];
        let generatedGcode = ""; 
        let imgWidth = 0, imgHeight = 0;
        
        let allParsedLines = [];
        
        // æ’å€¼åŠ¨ç”»ç›¸å…³å˜é‡
        let lastDrawnIndex = 0;   
        let displayIndex = 0;     
        let targetIndex = 0;      
        let animationFrameId = null;

        let audioChunks = [];
        let isRecording = false;
        let audioCtx = null;
        let isFullscreen = false;
        
        const imgCanvas = document.getElementById('imgCanvas');
        const imgCtx = imgCanvas.getContext('2d');
        const twinCanvas = document.getElementById('twinCanvas');
        const twinCtx = twinCanvas.getContext('2d');

        window.onload = () => {
            resizeTwinCanvas();
            window.addEventListener('resize', resizeTwinCanvas);
            startRenderLoop();
        };

        // --- è“ç‰™è¿æ¥é€»è¾‘ ---
        async function toggleConnection() { if (isConnected) await disconnectBLE(); else connectBLE(); }
        async function connectBLE() {
            if (!navigator.bluetooth) return alert("æµè§ˆå™¨ä¸æ”¯æŒè“ç‰™");
            updateStatus("æ­£åœ¨æœç´¢è®¾å¤‡...", "blue");
            try {
                device = await navigator.bluetooth.requestDevice({ filters: [{ services: [SERVICE_UUID] }], optionalServices: [SERVICE_UUID] });
                device.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                charCmd = await service.getCharacteristic(CHAR_CMD_UUID);
                charStat = await service.getCharacteristic(CHAR_STAT_UUID);
                charAudio = await service.getCharacteristic(CHAR_AUDIO_UUID);
                await charStat.startNotifications();
                charStat.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                await charAudio.startNotifications();
                charAudio.addEventListener('characteristicvaluechanged', handleAudioData);
                onConnected();
            } catch (e) {
                if(e.message.includes("cancelled")) updateStatus("ç”¨æˆ·å·²å–æ¶ˆ", "black");
                else { updateStatus("è¿æ¥å¤±è´¥: " + e.message, "red"); console.error(e); }
            }
        }
        async function disconnectBLE() { if (device) { if(device.gatt.connected) await device.gatt.disconnect(); try { if(device.forget) await device.forget(); } catch(e) {} } }
        function onConnected() { isConnected = true; document.getElementById('btText').innerText = "å·²è¿æ¥"; document.getElementById('btIcon').innerText = "âœ…"; const btn = document.getElementById('connectBtn'); btn.style.borderColor = "var(--success)"; btn.style.color = "var(--success)"; updateStatus("è®¾å¤‡å·²å°±ç»ª", "green"); toggleTurbo(); if (generatedGcode) document.getElementById('uploadBtn').disabled = false; }
        function onDisconnected() { isConnected = false; document.getElementById('btText').innerText = "è¿æ¥è®¾å¤‡"; document.getElementById('btIcon').innerText = "ğŸ“¡"; const btn = document.getElementById('connectBtn'); btn.style.borderColor = "#E5E5EA"; btn.style.color = "var(--primary)"; setBreathing(false); document.getElementById('uploadBtn').disabled = true; document.getElementById('controlBtn').classList.add('hidden'); document.getElementById('uploadBtn').classList.remove('hidden'); updateStatus("è®¾å¤‡å·²æ–­å¼€", "red"); }

        // --- åŠ¨ç”»å¾ªç¯æ¸²æŸ“å¼•æ“ ---
        function startRenderLoop() {
            function render() {
                if (displayIndex < targetIndex) {
                    const diff = targetIndex - displayIndex;
                    const step = 0.05 + (diff * 0.1); 
                    const nextIndex = Math.min(displayIndex + step, targetIndex);
                    drawSegment(displayIndex, nextIndex);
                    displayIndex = nextIndex;
                }
                animationFrameId = requestAnimationFrame(render);
            }
            render();
        }

        // --- éŸ³é¢‘ä¸çŠ¶æ€ ---
        function handleAudioData(e) { if (!isRecording) return; const data = new Uint8Array(e.target.value.buffer); for(let i=0; i<data.length; i++) audioChunks.push(data[i]); document.getElementById('audioStats').innerText = `å·²æ¥æ”¶: ${(audioChunks.length/1024).toFixed(1)} KB`; }
        function startLocalRecording() { isRecording = true; audioChunks = []; document.getElementById('recIndicator').classList.add('recording-active'); updateStatus("ğŸ™ï¸ æ­£åœ¨å½•éŸ³...", "red"); document.getElementById('playRecBtn').disabled = true; }
        function stopLocalRecording() { isRecording = false; document.getElementById('recIndicator').classList.remove('recording-active'); updateStatus("å½•éŸ³å®Œæˆ", "green"); document.getElementById('playRecBtn').disabled = false; document.getElementById('audioStats').innerText = `å°±ç»ª: ${(audioChunks.length/1024).toFixed(1)} KB`; }
        function playLastRecording() { if (audioChunks.length === 0) return; if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); const sampleRate = 8000; const buffer = audioCtx.createBuffer(1, audioChunks.length, sampleRate); const channelData = buffer.getChannelData(0); for (let i = 0; i < audioChunks.length; i++) channelData[i] = (audioChunks[i] - 128) / 128.0; const source = audioCtx.createBufferSource(); source.buffer = buffer; source.connect(audioCtx.destination); source.start(); updateStatus("â–¶ï¸ æ­£åœ¨æ’­æ”¾...", "blue"); source.onended = () => updateStatus("æ’­æ”¾ç»“æŸ", "black"); }
        
        function handleStatusUpdate(e) {
            const val = e.target.value; const dec = new TextDecoder(); const str = dec.decode(val);
            try {
                const d = JSON.parse(str);
                if (d.rec !== undefined) { if (d.rec === 1) startLocalRecording(); else stopLocalRecording(); return; }
                const btn = document.getElementById('controlBtn');
                if(d.s === 1) { 
                    if(!btn.innerText.includes("æš‚åœ")) { btn.innerText = "â¸ æš‚åœ"; btn.className = "btn btn-danger col-span-2"; btn.disabled = false; btn.classList.remove('hidden'); document.getElementById('uploadBtn').classList.add('hidden'); setBreathing(true); }
                    const total = allParsedLines.length; const pct = total>0 ? Math.round((d.i/total)*100) : 0;
                    document.getElementById('progressFill').style.width = pct+"%"; updateStatus(`ç»˜ç”»ä¸­: ${pct}%`, "green");
                    targetIndex = d.i; 
                } else if(d.s === 2) { 
                    if(!btn.innerText.includes("ç»§ç»­")) { btn.innerText = "â–¶ ç»§ç»­"; btn.className = "btn btn-success col-span-2"; setBreathing(false); }
                } else if(d.s === 3) { 
                    updateStatus("å®Œæˆ! ğŸ‰", "green"); btn.innerText = "â–¶ å†æ¬¡ç»˜ç”»"; btn.className = "btn btn-success col-span-2"; setBreathing(false);
                    if (lastDrawnIndex > 0) drawSegment(0, lastDrawnIndex, true); 
                }
            } catch(err){}
        }
        async function sendCommand(cmd) { if(!charCmd) return; const enc = new TextEncoder(); await charCmd.writeValue(enc.encode(cmd)); }
        function sendTestAudio() { const id = document.getElementById('testTrackInput').value; if(id) sendCommand('CMD:TEST_AUDIO:' + id); }
        async function toggleTurbo() { if(!isConnected) return; const on = document.getElementById('turboToggle').checked; await sendCommand(on ? "CMD:TURBO_ON" : "CMD:TURBO_OFF"); }
        function updateStatus(msg, color) { const el = document.getElementById('status'); el.innerText = msg; if(color==='red') el.style.color = 'var(--danger)'; else if(color==='green') el.style.color = 'var(--success)'; else el.style.color = 'var(--text-main)'; }
        function setBreathing(enable) { const st = document.getElementById('status'); if(enable) st.classList.add('status-breathing'); else st.classList.remove('status-breathing'); }
        function toggleDebug() { const p = document.getElementById('debugPanel'); p.classList.toggle('hidden'); }
        function downloadGcode() { if (!generatedGcode) return alert("è¯·å…ˆè½¬æ¢å›¾ç‰‡ç”Ÿæˆ G-Code"); const blob = new Blob([generatedGcode], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'robot_drawing.gcode'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }

        // --- å›¾åƒå¤„ç†æ ¸å¿ƒé€»è¾‘ ---
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = function(evt) {
                const img = new Image();
                img.onload = function() {
                    resetUIForNewImage();
                    const maxSize = 800; let w = img.width, h = img.height;
                    if (w > maxSize || h > maxSize) { const ratio = Math.min(maxSize / w, maxSize / h); w = Math.round(w * ratio); h = Math.round(h * ratio); }
                    imgWidth = w; imgHeight = h;
                    const aspectRatio = (h / w) * 100 + "%";
                    document.getElementById('imgContainer').style.paddingTop = aspectRatio; document.getElementById('twinContainer').style.paddingTop = aspectRatio;
                    imgCanvas.width = w; imgCanvas.height = h; imgCtx.drawImage(img, 0, 0, w, h);
                    originalImage = imgCtx.getImageData(0, 0, w, h);
                    document.getElementById('imgPlaceholder').style.display = 'none';
                    const pBtn = document.getElementById('processBtn'); pBtn.disabled = false; pBtn.classList.remove('btn-success'); pBtn.classList.add('btn-primary');
                    document.getElementById('processBtnText').innerText = "âœ¨ è½¬æ¢å›¾ç‰‡ä¸ºè·¯å¾„";
                    document.getElementById('pathStats').innerText = `å›¾ç‰‡: ${w}x${h}px`;
                    generatedGcode = ""; rawPaths = [];
                    document.getElementById('uploadBtn').disabled = true; document.getElementById('downloadBtn').disabled = true;
                    updateBinaryPreview(); setTimeout(resizeTwinCanvas, 100);
                }; img.src = evt.target.result;
            }; reader.readAsDataURL(file);
        });

        function resetUIForNewImage() { 
            document.getElementById('controlBtn').classList.add('hidden'); 
            document.getElementById('uploadBtn').classList.remove('hidden'); 
            document.getElementById('uploadBtn').disabled = true; 
            document.getElementById('uploadBtn').innerText = "ğŸ“¡ å‘é€ä»»åŠ¡"; 
            document.getElementById('progressFill').style.width = "0%"; 
            setBreathing(false); 
            updateStatus("å›¾ç‰‡å·²åŠ è½½", "black"); 
            document.getElementById('downloadBtn').disabled = true;
            displayIndex = 0; targetIndex = 0; 
            twinCtx.clearRect(0,0,twinCanvas.width,twinCanvas.height);
        }
        
        document.getElementById('threshold').addEventListener('input', (e) => { document.getElementById('thresholdVal').innerText = e.target.value; if(originalImage) updateBinaryPreview(); });
        document.getElementById('smoothing').addEventListener('input', (e) => { document.getElementById('smoothingVal').innerText = e.target.value; if(rawPaths && rawPaths.length > 0) updatePathsAndGcode(); });
        document.getElementById('minLength').addEventListener('input', (e) => { document.getElementById('minLengthVal').innerText = e.target.value; if(rawPaths && rawPaths.length > 0) updatePathsAndGcode(); });

        function updateBinaryPreview() {
            if(!originalImage) return; const th = parseInt(document.getElementById('threshold').value);
            const output = imgCtx.createImageData(imgWidth, imgHeight); const d = originalImage.data; const out = output.data;
            for(let i=0; i<d.length; i+=4) { const gray = 0.34*d[i] + 0.5*d[i+1] + 0.16*d[i+2]; const val = gray < th ? 0 : 255; out[i]=out[i+1]=out[i+2]=val; out[i+3]=255; }
            imgCtx.putImageData(output, 0, 0);
        }

        async function processImage() {
            if(!originalImage) return; const btn = document.getElementById('processBtn'); const loader = document.getElementById('loader'); const txt = document.getElementById('processBtnText');
            btn.disabled = true; loader.classList.remove('hidden'); txt.innerText = "æ­£åœ¨è¿ç®—...";
            setTimeout(() => {
                try {
                    const th = parseInt(document.getElementById('threshold').value); const hollow = document.getElementById('hollowSolids').checked;
                    prepareBinaryData(th);
                    if(hollow) hollowSolids();
                    skeletonize();
                    tracePaths(); 
                    updatePathsAndGcode();
                    btn.classList.remove('btn-primary'); btn.classList.add('btn-success');
                    updateStatus("è½¬æ¢æˆåŠŸï¼Œå‡†å¤‡å‘é€", "green"); document.getElementById('downloadBtn').disabled = false;
                } catch(e) { console.error(e); updateStatus("ç®—æ³•é”™è¯¯", "red"); } finally { btn.disabled = false; loader.classList.add('hidden'); txt.innerText = "âœ¨ è½¬æ¢å®Œæˆ"; }
            }, 50);
        }

        function updatePathsAndGcode() {
            const sm = parseFloat(document.getElementById('smoothing').value);
            const minLen = parseFloat(document.getElementById('minLength').value);
            const WORK_WIDTH = 100.0; const scale = WORK_WIDTH / Math.max(imgWidth, 1);
            const sorted = sortAndMergePaths(rawPaths);
            let tempPaths = sorted.map(p => simplifyPathRDP(p, sm));
            optimizedPaths = tempPaths.filter(path => {
                if(path.length < 2) return false;
                let lenPx = 0;
                for(let i=1; i<path.length; i++) {
                    const dx = path[i].x - path[i-1].x; const dy = path[i].y - path[i-1].y;
                    lenPx += Math.sqrt(dx*dx + dy*dy);
                }
                return (lenPx * scale) >= minLen;
            });
            generateGcodeInternal();
            const pts = optimizedPaths.reduce((a,p)=>a+p.length,0);
            document.getElementById('pathStats').innerText = `è·¯å¾„: ${optimizedPaths.length} (åŸ${tempPaths.length}) | èŠ‚ç‚¹: ${pts}`;
            resizeTwinCanvas(); if(isConnected) document.getElementById('uploadBtn').disabled = false; if(generatedGcode) document.getElementById('downloadBtn').disabled = false;
        }

        function prepareBinaryData(th) { binaryData = new Int8Array(imgWidth*imgHeight); const d = originalImage.data; for(let i=0; i<imgWidth*imgHeight; i++) { const val = (0.34*d[i*4]+0.5*d[i*4+1]+0.16*d[i*4+2]); binaryData[i] = val < th ? 1 : 0; } }
        function getPixel(x,y){ if(x<0||x>=imgWidth||y<0||y>=imgHeight)return 0; return binaryData[y*imgWidth+x]; }
        function hollowSolids() { const t = new Int8Array(binaryData); for(let y=1; y<imgHeight-1; y++) { for(let x=1; x<imgWidth-1; x++) { const idx = y*imgWidth+x; if(t[idx] && t[idx-1] && t[idx+1] && t[idx-imgWidth] && t[idx+imgWidth]) binaryData[idx]=0; } } }
        
        function skeletonize() {
            let changed=true; const rem=[];
            while(changed) {
                changed=false;
                for(let pass=0; pass<2; pass++) {
                    rem.length=0;
                    for(let y=1; y<imgHeight-1; y++){
                        for(let x=1; x<imgWidth-1; x++){
                            if(getPixel(x,y)){
                                const p2=getPixel(x,y-1), p3=getPixel(x+1,y-1), p4=getPixel(x+1,y);
                                const p5=getPixel(x+1,y+1), p6=getPixel(x,y+1), p7=getPixel(x-1,y+1);
                                const p8=getPixel(x-1,y), p9=getPixel(x-1,y-1);
                                const A = (p2==0&&p3==1)+(p3==0&&p4==1)+(p4==0&&p5==1)+(p5==0&&p6==1)+(p6==0&&p7==1)+(p7==0&&p8==1)+(p8==0&&p9==1)+(p9==0&&p2==1);
                                const B = p2+p3+p4+p5+p6+p7+p8+p9;
                                const m1 = pass==0 ? (p2*p4*p6) : (p2*p4*p8);
                                const m2 = pass==0 ? (p4*p6*p8) : (p2*p6*p8);
                                if(A==1 && B>=2 && B<=6 && m1==0 && m2==0) rem.push(y*imgWidth+x);
                            }
                        }
                    }
                    if(rem.length>0){ changed=true; for(let i=0; i<rem.length; i++) binaryData[rem[i]]=0; }
                }
            }
        }

        function tracePaths() {
            rawPaths = [];
            const visited = new Int8Array(imgWidth * imgHeight);
            const dirs = [{dx:1,dy:0}, {dx:1,dy:1}, {dx:0,dy:1}, {dx:-1,dy:1}, {dx:-1,dy:0}, {dx:-1,dy:-1}, {dx:0,dy:-1}, {dx:1,dy:-1}];
            for (let y = 0; y < imgHeight; y++) {
                for (let x = 0; x < imgWidth; x++) {
                    const idx = y * imgWidth + x;
                    if (binaryData[idx] && !visited[idx]) {
                        let path = [];
                        let cx = x, cy = y;
                        path.push({x: cx, y: cy});
                        visited[cy * imgWidth + cx] = 1;
                        while (true) {
                            let found = -1;
                            for (let i = 0; i < 8; i++) {
                                const nx = cx + dirs[i].dx, ny = cy + dirs[i].dy;
                                if (nx >= 0 && nx < imgWidth && ny >= 0 && ny < imgHeight) {
                                    const nIdx = ny * imgWidth + nx;
                                    if (binaryData[nIdx] && !visited[nIdx]) { found = i; break; }
                                }
                            }
                            if (found !== -1) { cx += dirs[found].dx; cy += dirs[found].dy; path.push({x: cx, y: cy}); visited[cy * imgWidth + cx] = 1; } else break;
                        }
                        let bx = x, by = y;
                        while(true) {
                             let found = -1;
                            for (let i = 0; i < 8; i++) {
                                const nx = bx + dirs[i].dx, ny = by + dirs[i].dy;
                                if (nx >= 0 && nx < imgWidth && ny >= 0 && ny < imgHeight) {
                                    const nIdx = ny * imgWidth + nx;
                                    if (binaryData[nIdx] && !visited[nIdx]) { found = i; break; }
                                }
                            }
                            if (found !== -1) { bx += dirs[found].dx; by += dirs[found].dy; path.unshift({x: bx, y: by}); visited[by * imgWidth + bx] = 1; } else break;
                        }
                        if (path.length > 2) rawPaths.push(path);
                    }
                }
            }
        }

        function sortAndMergePaths(paths) {
            if(paths.length===0) return [];
            let rem = paths.map(p=>[...p]), sorted = [], curr = rem.shift();
            const MERGE_DIST_SQ = 25; 
            while(true) {
                let best=-1, minD=Infinity, rev=false, tip=curr[curr.length-1];
                for(let i=0; i<rem.length; i++) {
                    const start=rem[i][0], end=rem[i][rem[i].length-1];
                    const d1=(tip.x-start.x)**2+(tip.y-start.y)**2;
                    const d2=(tip.x-end.x)**2+(tip.y-end.y)**2;
                    if(d1<minD){minD=d1; best=i; rev=false;}
                    if(d2<minD){minD=d2; best=i; rev=true;}
                }
                if(best===-1) { sorted.push(curr); if(rem.length>0) { curr=rem.shift(); continue; } else break; }
                if(minD <= MERGE_DIST_SQ) { const next=rem[best]; if(rev) next.reverse(); curr.push(...next); rem.splice(best,1); } 
                else { sorted.push(curr); const next=rem[best]; if(rev) next.reverse(); curr=next; rem.splice(best,1); }
            }
            return sorted;
        }

        function simplifyPathRDP(path, epsilon) {
            if (path.length < 3) return path; 
            let dmax = 0, index = 0; const end = path.length - 1;
            const lineStart = path[0], lineEnd = path[end];
            for (let i = 1; i < end; i++) {
                const p = path[i];
                let d = 0;
                const dx = lineEnd.x - lineStart.x, dy = lineEnd.y - lineStart.y;
                const lenSq = dx * dx + dy * dy;
                if (lenSq === 0) d = Math.sqrt((p.x - lineStart.x)**2 + (p.y - lineStart.y)**2);
                else { let t = ((p.x - lineStart.x) * dx + (p.y - lineStart.y) * dy) / lenSq; if (t < 0) t = 0; else if (t > 1) t = 1; d = Math.sqrt((p.x - (lineStart.x + t * dx))**2 + (p.y - (lineStart.y + t * dy))**2); }
                if (d > dmax) { index = i; dmax = d; }
            }
            if (dmax > epsilon) { const r1 = simplifyPathRDP(path.slice(0, index + 1), epsilon); const r2 = simplifyPathRDP(path.slice(index, path.length), epsilon); return r1.slice(0, r1.length - 1).concat(r2); } else return [path[0], path[end]];
        }

        function generateGcodeInternal() {
            const WORK_WIDTH = 100.0; const scale = WORK_WIDTH / Math.max(imgWidth, 1);
            let g = "G90\nM5\n";
            optimizedPaths.forEach(p => {
                if(p.length===0) return;
                g+=`G0 X${(p[0].x*scale).toFixed(2)} Y${((imgHeight-p[0].y)*scale).toFixed(2)}\nM3 S1000\n`;
                for(let i=1; i<p.length; i++) g+=`G1 X${(p[i].x*scale).toFixed(2)} Y${((imgHeight-p[i].y)*scale).toFixed(2)}\n`;
                g+=`M5\n`;
            });
            g+="G0 X0 Y0\n"; generatedGcode = g; parseAllLines(g); drawTwinPreview(g, '#e0e0e0');
        }

        async function startUploadAndPrint() {
            if(!generatedGcode || !charCmd) return;
            const btn = document.getElementById('uploadBtn');
            btn.disabled = true; btn.innerText = "â³ ä¼ è¾“ä¸­...";
            displayIndex = 0; targetIndex = 0; 
            setBreathing(true);
            try {
                updateStatus("æ­£åœ¨åˆå§‹åŒ–...", "blue"); await sendCommand("CMD:NEWFILE");
                const rawLines = generatedGcode.split('\n');
                const validLines = [];
                for(let l of rawLines) { l = l.trim(); if(l) validLines.push(l); }
                generatedGcode = validLines.join('\n') + '\n';
                parseAllLines(generatedGcode);
                let chunk = ""; const CHUNK=150; 
                for(let i=0; i<validLines.length; i++) {
                    let line = validLines[i] + "\n";
                    if(chunk.length + line.length > CHUNK) {
                        await sendCommand(chunk); chunk = "";
                        if(i%5===0) { const pct = Math.round((i/validLines.length)*100); document.getElementById('progressFill').style.width = pct+"%"; updateStatus(`ä¸Šä¼ ä¸­: ${pct}%`, "blue"); await new Promise(r=>setTimeout(r, 5)); }
                    }
                    chunk += line;
                }
                if(chunk) await sendCommand(chunk);
                document.getElementById('progressFill').style.width = "100%";
                updateStatus("ä¸Šä¼ å®Œæˆï¼Œè¯·å¼€å§‹", "green");
                await sendCommand("CMD:TEST_AUDIO:3");
                btn.classList.add('hidden'); document.getElementById('controlBtn').classList.remove('hidden');
            } catch(e) {
                updateStatus("ä¸Šä¼ å¤±è´¥", "red"); setBreathing(false); btn.disabled = false; btn.innerText = "ğŸ“¡ é‡è¯•";
            }
        }

        async function toggleDrawing() {
            const btn = document.getElementById('controlBtn');
            if(btn.innerText.includes("å¼€å§‹") || btn.innerText.includes("ç»§ç»­") || btn.innerText.includes("å†æ¬¡")) {
                await sendCommand("CMD:START");
                btn.innerText = "â¸ æš‚åœ"; btn.className = "btn btn-danger col-span-2";
                updateStatus("ç»˜ç”»ä¸­...", "green"); setBreathing(true); 
            } else {
                await sendCommand("CMD:STOP");
                btn.innerText = "â–¶ ç»§ç»­"; btn.className = "btn btn-success col-span-2";
                updateStatus("å·²æš‚åœ", "orange"); setBreathing(false); 
            }
        }

        function parseAllLines(text) {
            allParsedLines = []; let cx=0, cy=0, down=false;
            const container = document.getElementById('twinContainer');
            const cw = container.clientWidth || 300; const ch = container.clientHeight || 300;
            const scale = (cw*0.9)/100.0, ox = cw*0.05, oy = ch*0.05;
            const lines = text.trim().split('\n');
            lines.forEach(l => {
                if(l.includes('M3')) down=true; if(l.includes('M5')) down=false;
                const zm = l.match(/Z([-\d.]+)/); if(zm) down=(parseFloat(zm[1])<=0);
                const xm = l.match(/X([-\d.]+)/), ym = l.match(/Y([-\d.]+)/);
                const gx = xm?parseFloat(xm[1]):cx; const gy = ym?parseFloat(ym[1]):cy;
                const tx = gx*scale + ox; const ty = ch - (gy*scale) - oy;
                allParsedLines.push({x:tx, y:ty, down:down, valid:(l.includes('G0')||l.includes('G1'))});
                if(xm) cx=gx; if(ym) cy=gy;
            });
        }

        // [ä¿®æ”¹] é¢„è§ˆå‡½æ•°ï¼šæ¢å¤çº¯å‡€çš„èƒŒæ™¯åº•å›¾ï¼Œä¸ç”»çº¢è‰²æ ‡è®°
        function drawTwinPreview(txt, col) {
            twinCtx.clearRect(0,0,twinCanvas.width,twinCanvas.height);
            twinCtx.lineCap='round'; twinCtx.lineJoin='round';
            
            // ç»˜åˆ¶ç°è‰²åº•å›¾ï¼ˆæ‰€æœ‰æœ‰æ•ˆè·¯å¾„ï¼‰
            twinCtx.beginPath(); twinCtx.strokeStyle=col; twinCtx.lineWidth=1;
            if(allParsedLines.length===0) return;
            twinCtx.moveTo(allParsedLines[0].x, allParsedLines[0].y);
            for(let i=1; i<allParsedLines.length; i++) {
                const p = allParsedLines[i];
                if(p.valid) { if(p.down) twinCtx.lineTo(p.x, p.y); else twinCtx.moveTo(p.x, p.y); }
            }
            twinCtx.stroke();
            // [åˆ é™¤] æ­¤å¤„åŸå…ˆç»˜åˆ¶çº¢è‰² G0 é¢„è§ˆçš„ä»£ç å·²ç§»é™¤ï¼Œç§»è‡³åŠ¨æ€ç»˜åˆ¶
        }

        function drawArrow(ctx, x1, y1, x2, y2) {
            const dist = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
            if(dist < 2) return; 
            const headLen = 4; 
            const angle = Math.atan2(y2-y1, x2-x1);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI/6), y2 - headLen * Math.sin(angle - Math.PI/6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI/6), y2 - headLen * Math.sin(angle + Math.PI/6));
            ctx.strokeStyle = '#FF3B30';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // [ä¿®æ”¹] åŠ¨æ€ç»˜åˆ¶å‡½æ•°ï¼šé›†æˆ G0 çº¢çº¿ã€ç®­å¤´å’Œç«¯ç‚¹åœ†åœˆçš„ç»˜åˆ¶é€»è¾‘
        function drawSegment(start, end, forceRed = false) {
            if (allParsedLines.length < 2) return;

            let startIdx = Math.floor(start);
            let endIdx = Math.floor(end);
            
            if (endIdx >= allParsedLines.length - 1) endIdx = allParsedLines.length - 2;
            if (startIdx >= allParsedLines.length - 1) startIdx = allParsedLines.length - 2;
            
            for (let i = startIdx; i <= endIdx; i++) {
                let p1 = allParsedLines[i];
                let p2 = allParsedLines[i+1];
                if (!p2) break;

                let rStart = (i === startIdx) ? (start - i) : 0;
                let rEnd = (i === endIdx) ? (end - i) : 1;
                
                let xStart = p1.x + (p2.x - p1.x) * rStart;
                let yStart = p1.y + (p2.y - p1.y) * rStart;
                let xEnd   = p1.x + (p2.x - p1.x) * rEnd;
                let yEnd   = p1.y + (p2.y - p1.y) * rEnd;

                // ç»˜åˆ¶å½“å‰çº¿æ®µï¼ˆè“çº¿æˆ–çº¢çº¿ï¼‰
                twinCtx.beginPath();
                twinCtx.moveTo(xStart, yStart);
                twinCtx.lineTo(xEnd, yEnd);
                
                if (p2.down) {
                    twinCtx.strokeStyle = '#007AFF';
                    twinCtx.lineWidth = 2;
                    twinCtx.stroke();
                } else {
                    // å¦‚æœæ˜¯ G0 æŠ¬ç¬”ç§»åŠ¨
                    if (Math.abs(xEnd - xStart) > 0.1 || Math.abs(yEnd - yStart) > 0.1) {
                        twinCtx.strokeStyle = 'rgba(255, 59, 48, 0.6)';
                        twinCtx.lineWidth = 1;
                        twinCtx.stroke();

                        // [æ–°å¢] å¦‚æœæ˜¯è¯¥æ®µç©ºç§»çš„èµ·ç‚¹ (rStart=0)ï¼Œç”»æŠ¬ç¬”çº¢åœˆ
                        if (rStart === 0) {
                             twinCtx.beginPath();
                             twinCtx.strokeStyle = '#FF3B30';
                             twinCtx.lineWidth = 1;
                             twinCtx.arc(xStart, yStart, 2, 0, 2 * Math.PI);
                             twinCtx.stroke();
                        }

                        // [æ–°å¢] å¦‚æœè¯¥æ®µç©ºç§»å·²èµ°å®Œ (rEnd=1)ï¼Œç”»è½ç¬”çº¢åœˆ + ç®­å¤´
                        if (rEnd === 1) {
                             drawArrow(twinCtx, xStart, yStart, xEnd, yEnd);
                             
                             twinCtx.beginPath();
                             twinCtx.strokeStyle = '#FF3B30';
                             twinCtx.lineWidth = 1;
                             twinCtx.arc(xEnd, yEnd, 2, 0, 2 * Math.PI);
                             twinCtx.stroke();
                        }
                    }
                }
            }
        }

        function resizeTwinCanvas() {
            const container = isFullscreen ? fullscreenModal : document.getElementById('imgContainer');
            const rect = document.getElementById('twinContainer').getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            twinCanvas.width = rect.width * dpr; twinCanvas.height = rect.height * dpr;
            twinCtx.scale(dpr, dpr);
            if(generatedGcode) drawTwinPreview(generatedGcode, '#e0e0e0');
            if(displayIndex > 0) drawSegment(0, displayIndex);
        }
        function toggleFullscreen(show) {
            isFullscreen = show; const c = document.getElementById('imgContainer');
            if (show) { fullscreenModal.classList.remove('hidden'); fullscreenModal.appendChild(imgCanvas); } 
            else { fullscreenModal.classList.add('hidden'); c.appendChild(imgCanvas); }
        }
    </script>
</body>
</html>